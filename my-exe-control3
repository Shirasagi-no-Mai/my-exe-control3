import openpyxl
from openpyxl import Workbook
from selenium.common.exceptions import ElementNotInteractableException
from openpyxl.styles import PatternFill
import re
import sys
import tkinter as tk
import inspect

from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.service import Service
from webdriver_manager.chrome import ChromeDriverManager
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, NoSuchElementException
from selenium.webdriver.common.action_chains import ActionChains
from datetime import datetime
import os
import time
from selenium.common.exceptions import NoAlertPresentException
from selenium.webdriver.support.ui import Select
from selenium.common.exceptions import StaleElementReferenceException
from tkinter import Toplevel
from tkinter import ttk
import requests
from collections import Counter
import shutil
import glob
from seleniumwire.utils import decode
import requests
import json
import base64
import zlib
import gzip
import subprocess
from requests.exceptions import ConnectionError, Timeout, RequestException
import traceback
from openpyxl import load_workbook
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
from requests.exceptions import ConnectionError, Timeout, RequestException
import msoffcrypto
import string
import re
import numpy as np  # 导入numpy以检查NaN和Inf值

# *************************通过个人网页更新过期日期*************************************************************************
CONFIG_URL = "https://raw.githubusercontent.com/Shirasagi-no-Mai/my-exe-control/main/expiration_config.json"


def fetch_expiration_date():
    try:
        response = requests.get(CONFIG_URL)
        response.raise_for_status()
        config = json.loads(response.text)
        return datetime.strptime(config['expiration_date'], '%Y-%m-%d')
    except requests.exceptions.RequestException as e:
        print(f"网络请求失败: {e}")

        return None
    except (json.JSONDecodeError, KeyError, ValueError) as e:
        print(f"解析错误: {e}")
        return None


expiration_date1 = fetch_expiration_date()
print(f"expiration_date1: {expiration_date1}")






# ② 功能权限配置
# ----------------------------
PERMISSION_URL = "https://raw.githubusercontent.com/Shirasagi-no-Mai/my-exe-control2/refs/heads/main/onlinecode"

def fetch_permissions():
    """从远程读取功能权限列表"""
    try:
        response = requests.get(PERMISSION_URL, timeout=10)
        response.raise_for_status()
        data = response.json()
        permissions = {f["name"]: f["allowed_users"] for f in data.get("functions", [])}
        return permissions
    except requests.exceptions.RequestException as e:
        print(f"网络请求失败: {e}")
    except (json.JSONDecodeError, KeyError, ValueError) as e:
        print(f"解析错误: {e}")
    return {}


permissions = fetch_permissions()


def is_user_allowed(func_name, username):
    """检查用户是否有权限执行某函数"""
    return username in permissions.get(func_name, [])


# ----------------------------
# ✅ 示例执行
# ----------------------------


permissions = fetch_permissions()
print("权限列表示例：")
print(json.dumps(permissions, indent=2, ensure_ascii=False))








# *************************通过个人网页更新过期日期*************************************************************************


# *************************预设*****************************************************************************************

# 更新输出文本框
windowname = ""
from selenium.common.exceptions import UnexpectedAlertPresentException, ElementClickInterceptedException


def update_output_text(output_text, message):
    output_text.insert(tk.END, message)
    output_text.yview(tk.END)


# *************************预设*****************************************************************************************

def FDA_program(account, password, output_text):
    expiration_date = expiration_date1
    now = datetime.now()
    func_name = inspect.currentframe().f_code.co_name  # 自动获取当前函数名

    if expiration_date and now > expiration_date:
        if not is_user_allowed(func_name, account):
            update_output_text(output_text, "程序已过期，请联系Larry获取更新版本。\n\n")
            exit()

    user_home = os.path.expanduser("~")
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "BBCreview.xlsx")
        if os.path.exists(file_path):
            update_output_text(output_text, f"找到文件：{file_path}\n\n")
        else:
            # 创建空的 Excel 文件
            wb = Workbook()
            wb.save(file_path)
            update_output_text(output_text, f"未找到文件，已创建新文件,下次运行将开始操作：{file_path}\n\n")
            sys.exit()  # 程序立即停止
    else:
        update_output_text(output_text, "未找到有效的桌面路径\n\n")
        sys.exit()  # 程序立即停止

    def get_fda_entry_status(entry_number):
        url = f"https://www.access.fda.gov/itacs/ws/api/submission/{entry_number}/?feiNum=null&token=0cAFcWeA4bdocblwHFTljvFqa3R0J9MmTPnL4y3c-ZWc-dFVlUW6_ua7RrUeBfJZ0eWw5OZvzUiHzYbi8jxmuzPPYdP6qb2t7565VZOVd8ETPtIGW9oavQ8Sy9Mv-zTGtfgcSX3WSzOjamHdgWysPtHC55CBPM_aHvqmHRbDEofVrqyjU-tJ6sn5cNO7sTffZ-DVwTjJwGgUC3GCUyXr-ExK7NYuJK44maAlK5jRtgwCbb4g-YjzCLK2dQNgn31pf8j0MMwjCq3cmEIYBG8dvH2pGVipjf4cRvI3ID0NBpFGPKT-B4CHg3wU5Pcx7oju6WUeldAN30Qnn7I_Rt3MC4VvxKwt3sye_IynRWC5McJ0nlFySsnD-qWuIuFGXNl-FFid8Te6BunF_xtljwm1TKFSZ7aug-SLt44dzCL_ljLCoWVVXh0j64_JWNDknU1VqbfycWggHlPF1Txgh1_6Z7jZw-DKXBZj9Vy8A-zefvyfX5yBgWUubsAEEV1JPHKIyc7n5JWPzj5SoZ8_5tFLKJJnv4mEHLC2HQI_Qs6AFidS3JQdfuUlk1Nnh9Llrw0TFCMzndL4FJPI2y9mV0LnRiL7OQHrX1pa1wNFkHdMrmWoPLo89rHtftYKyuOp6IegWoha1CsivbD2SqyLGvPtxlXEdG2oOaH7OUEvWMNIp1S52Pzn5_9zYc2t9ddLmPskozKl78np2VEDmaAOFX5dvNYaXALBd8D2uIILPcg9d3Ux-p2D3k9CTNRLXRtO8IafAAJTefdCHxjyF5Kz1t-vPEE1u9jTOk1DkunSaVDsTgpvRvvDqebSOstg3Rn0tXd7-B1rpEJHwz09PU0-4vgPlwmAMTF6cFleF8mhG0D4nIaD2B9oa-9ryTUeo5jticNmeR3G9yBRNEXThh6bE1jZl2xRgmGgIZqHQXa2RC7j1r_cK4VoIv0r6Uq8Vg8JZI_boZsyncT3wyBzdkN17HUxglEVK8eR5zf1vUlU3iHmCiTHWsuyGaq6V2ie-N8admgEL5s3H6dqDdUYY961Ko4KkwZ3nhXMv9764I0QmxMk5Dkt-atvtwJr2Cqy6VRrims4S9ddVh1wdwRXOzf7FonHS6yiiM63sfMOSI7kyz0q3Xvn0bI9nIR1wTJydrsOdXkACwOaKCqCdZQCWUub23FPNXRAB2WUblWG_2bw-LdD5A2uxtHMnhPcFcVjGLeU4e8B2BBABuernaMTtTkYGJUzuZVhydvn8ITs538lPX-hKKWAdWaczpNPfuWc_jPM9zh5bAPQ82oqhWJd1ESMrCcyaZLojKjnGiDBaOGLiqAS6JfP8-nyHQaMySSXcnnaYicV7qxK65q282qZBa5s63-wC8bR6Q0unzZUWZXRwkO84Q0jxxcwizSD8quAZFLPSQbQFK8WPBW66eRk0rANpp8aGROxGWIBW4gg8PWSDFlX5mG8foUpV-eVUE9kXF8pbBl4SVxtacaMjvFV0hmhvnE5V4fbWlNQmvjC9_DhDAU5vKoTgOc0BPTXSbXKulLa23w8eL7SNcBFzSOy0cOfk5TqJxLajRV6dWBJuIY2LfWnhJTPOen3Vei-PUVKDygWvr8L6kmWKbIAqtE1HNMKSYgOEKtyfJdBNRNzZS-w"

        headers = {
            "accept": "application/json, text/plain, */*",
            "authorization": "Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJyb2xlcyI6IltcIlBVQkxJQ1wiXSIsImlzcyI6ImF1dGgwIiwiY3JlYXRlVGltZXN0YW1wIjoxNzU1ODk3NTQ3NTcxfQ.WCnz5k1mMk4pfBFa3zzCa_r4GoH9l3_1jMfxPTX5n6w",
            "referer": "https://www.access.fda.gov/itacs/",
            "user-agent": "Mozilla/5.0 (X11; Linux aarch64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36 CrKey/1.54.250320"
        }

        session = requests.Session()
        retries = Retry(total=3, backoff_factor=1, status_forcelist=[502, 503, 504])
        session.mount('https://', HTTPAdapter(max_retries=retries))

        try:
            response = session.get(url, headers=headers, timeout=30)
            if response.status_code == 200:
                return response.json()
            else:
                print(f"Error: {response.status_code}")
                return "N/A"
        except (ConnectionError, Timeout, RequestException) as e:
            print(f"请求失败: {e}")
            return "N/A"

    def get_cpsc_entry_status(entry_number):
        url = "https://www.cpsc.gov/shipmenttracking/api/entries"

        headers = {
            "accept": "*/*",
            "content-type": "application/json",
            "origin": "https://www.cpsc.gov",
            "referer": "https://www.cpsc.gov/shipmenttracking/",
            "user-agent": "Mozilla/5.0 (X11; Linux aarch64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36 CrKey/1.54.250320"
        }
        payload = {
            "entry_number": entry_number,
            "entry_line_number": "",
            "page_number": "",
            "page_size": ""
        }

        session = requests.Session()
        retries = Retry(total=3, backoff_factor=1, status_forcelist=[502, 503, 504])
        session.mount('https://', HTTPAdapter(max_retries=retries))

        try:
            response = session.post(url, headers=headers, json=payload, timeout=30)
            response.raise_for_status()  # 如果不是 200，会抛异常
            return response.json()
        except (ConnectionError, Timeout, RequestException) as e:
            print(f"请求失败: {e}")
            return "N/A"

    data = get_cpsc_entry_status('NUP18426901')
    print(data)

    def check_status_for_keyword(data):
        """
        检查 entry_lines 中的每一行 public_status 是否都包含
        "Released by" 或 "Entry Data Received"
        返回两个参数:
            - status (str): "released" 或 "not released: {status}"
            - earliest_proceed_date (str): 最早的日期，格式 MM/DD/YYYY hh:mm:ss AM/PM TZ，若无有效日期返回 ""
        """
        # 处理 data 为 "N/A" 的情况
        if data == "N/A":
            return "not found", ""

        entry_lines = data.get("entry_lines", [])
        if not entry_lines:
            return "not found", ""

        # 收集所有合法的 proceed_date
        dates = []
        for line in entry_lines:
            spcs_proceed_date = line.get("proceed_date", "").strip()
            if spcs_proceed_date and spcs_proceed_date.lower() != "n/a":
                try:
                    pd_no_tz = " ".join(spcs_proceed_date.split()[:-1])  # 去掉最后的 EDT
                    spcs_proceed_date_proceeded = datetime.strptime(pd_no_tz, "%m/%d/%Y %I:%M:%S %p")
                    dates.append(spcs_proceed_date_proceeded)
                except ValueError:
                    # 日期格式不匹配，忽略
                    pass

        earliest_date = min(dates).strftime("%m/%d/%Y %I:%M:%S %p") if dates else ""

        # 检查每条 public_status
        for line in entry_lines:
            status_text = line.get("public_status", "").lower()
            if "released" not in status_text and "entry data received" not in status_text:
                return f"not released: {line.get('public_status', '')}", earliest_date

        return "released", earliest_date

    file_path = os.path.join(desktop_path, "BBCreview.xlsx")

    # 打开 Excel
    wb = openpyxl.load_workbook(file_path)
    ws = wb.active
    first_column_values = [ws.cell(row=row, column=1).value for row in range(1, ws.max_row + 1)]
    update_output_text(output_text, f"所有要处理的entry:{first_column_values}\n")
    # 遍历第一列，获取 entry_number 并调用接口
    GREEN = PatternFill(start_color="00C6EFCE", end_color="00C6EFCE", fill_type="solid")  # 绿色
    RED = PatternFill(start_color="00FFC7CE", end_color="00FFC7CE", fill_type="solid")  # 红色

    # 初始化结果列表
    fda_results = []
    cpsc_results = []

    # 遍历第一列
    wb = openpyxl.load_workbook(file_path)
    ws = wb.active
    for row in range(1, ws.max_row + 1):
        cell_value = str(ws.cell(row=row, column=1).value)

        # 检查表头（避免对表头调用 API）
        if row == 1 and "entry" in cell_value.lower():
            fda_results.append("FDA Header")
            cpsc_results.append(("CPSC Header", ""))
            update_output_text(output_text, f"{cell_value}是表头，跳过API调用\n")
            continue

        # 检查 cell_value 是否为 8 位数字
        if not (cell_value.isdigit() and len(cell_value) == 8):
            fda_results.append("格式错误")
            cpsc_results.append(("格式错误", "格式错误"))
            update_output_text(output_text, f"{cell_value}格式错误，需为8位数字\n")
            continue

        # 格式化 entry number
        fda_entry_number = f"NUP-{cell_value[:-1]}-{cell_value[-1]}" if len(cell_value) >= 2 else cell_value
        cpsc_entry_number = f"NUP{cell_value}" if len(cell_value) >= 2 else cell_value

        # 获取 FDA 状态
        response1 = get_fda_entry_status(fda_entry_number)
        if not response1 or response1 == "N/A" or response1.get("status", "").upper() == "ERROR":
            entry_level_status1 = "FDA找不到此entry"
        else:
            if response1.get("entryLevelStatus") is None:
                if response1.get("entryActive", False):
                    entry_level_status1 = "No public status available"
                else:
                    entry_level_status1 = "entry closed"
            else:
                entry_level_status1 = response1.get("entryLevelStatus")

        # 获取 CPSC 状态
        response2 = get_cpsc_entry_status(cpsc_entry_number)
        if not response2 or response2 == "N/A":
            entry_level_status2 = "N/A"
            entry_level_status2_time = ""
        else:
            entry_level_status2, entry_level_status2_time = check_status_for_keyword(response2)

        fda_results.append(entry_level_status1)
        cpsc_results.append((entry_level_status2, entry_level_status2_time))
        update_output_text(output_text, f"{cell_value}运行完成\n")

    # 批量写入

    for row, (fda_res, cpsc_res) in enumerate(zip(fda_results, cpsc_results), start=1):
        # 写入第 3-5 列
        ws.cell(row=row, column=3, value=fda_res)
        ws.cell(row=row, column=4, value=cpsc_res[0])
        ws.cell(row=row, column=5, value=cpsc_res[1])

        # 第 3 列颜色标注
        if "FDA找不到此entry" in fda_res or "entry closed" in fda_res:
            ws.cell(row=row, column=3).fill = GREEN
        else:
            ws.cell(row=row, column=3).fill = RED

        # 第 6 列生成逻辑
        if "格式错误" in cpsc_res[0].lower():
            ws.cell(row=row, column=6, value="格式有问题跳过此行")
        else:
            if "not released" in cpsc_res[0].lower():
                ws.cell(row=row, column=6, value="CPSC REVIEW")
            elif "FDA找不到此entry" not in fda_res and "entry closed" not in fda_res:
                if "No public" in fda_res:

                    ws.cell(row=row, column=6, value="FDA REVIEW")
                elif "FDA entry status information is not" in fda_res:
                    ws.cell(row=row, column=6, value="MAY PROCEED")
                    ws.cell(row=row, column=7, value="Arrival Notifacation 也许可以放货")

                else:
                    ws.cell(row=row, column=6, value="FDA HOLD")

            else:
                ws.cell(row=row, column=6, value="MAY PROCEED")

    # 保存文件
    try:
        wb.save(file_path)
        update_output_text(output_text, "运行完成\n")
    except Exception as e:
        print(f"Error saving file: {e}")
        update_output_text(output_text, f"保存文件失败: {e}\n")

    wb.close()


def inbond_program(account, password, output_text):
    expiration_date = expiration_date1
    now = datetime.now()
    func_name = inspect.currentframe().f_code.co_name  # 自动获取当前函数名

    if expiration_date and now > expiration_date:
        if not is_user_allowed(func_name, account):
            update_output_text(output_text, "程序已过期，请联系Larry获取更新版本。\n\n")
            exit()

    # 获取用户主目录
    user_home = os.path.expanduser("~")

    # 检测可能的桌面路径
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    # 查找存在的桌面路径
    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "inbond extract.xlsx")
        if os.path.exists(file_path):
            update_output_text(output_text, f"找到文件：{file_path}\n\n")
        else:
            # 创建空的 Excel 文件
            wb = Workbook()
            wb.save(file_path)
            update_output_text(output_text, f"未找到文件，已创建新文件：{file_path}\n\n")
            sys.exit()  # 程序立即停止
    else:
        update_output_text(output_text, "未找到有效的桌面路径\n\n")
        sys.exit()  # 程序立即停止

    if desktop_path:
        file_path2 = os.path.join(desktop_path, "inbond output.xlsx")
        if os.path.exists(file_path2):
            update_output_text(output_text, f"找到文件：{file_path2}\n\n")
        else:
            # 创建空的 Excel 文件
            wb = Workbook()
            wb.save(file_path2)
            update_output_text(output_text, f"未找到文件，已创建新文件：{file_path2}\n\n")
            sys.exit()  # 程序立即停止
    else:
        update_output_text(output_text, "未找到有效的桌面路径\n\n")
        sys.exit()  # 程序立即停止
    # 读取 Excel 文件
    df = pd.read_excel(file_path, header=None)  # 关键修改：header=None

    # 初始化列表
    list61, list62, list63 = [], [], []

    # 确保 DataFrame 非空
    if not df.empty:
        first_col = df.iloc[:, 0]  # 获取第一列
        third_col = df.iloc[:, 2]  # 获取第三列

        # 处理第一列数据
        # cleaned_values = first_col.apply(lambda x: ''.join(filter(str.isdigit, str(x)))[-8:] if x else '')
        cleaned_values = first_col.apply(lambda x: str(x)[4:] if x and len(str(x)) > 4 else '')  # 取第一列除去前四位

        # 遍历每行数据，将数据按第三列的值分类
        for value, category in zip(cleaned_values, third_col):
            if value:  # 确保值非空
                if category == 61:
                    list61.append(value)
                elif category == 62:
                    list62.append(value)
                elif category == 63:
                    list63.append(value)
    update_output_text(output_text, f"list61:{list61}\n\n")
    update_output_text(output_text, f"list62:{list62}\n\n")
    update_output_text(output_text, f"list63:{list63}\n\n")
    try:
        # 配置 ChromeOptions
        options = webdriver.ChromeOptions()
        chrome_binary = r"C:\Program Files\Google\Chrome\Application\chrome.exe"
        options.binary_location = chrome_binary
        options.add_argument("--no-sandbox")
        options.add_argument("--disable-dev-shm-usage")

        # 检查 Chrome 可执行文件是否存在
        if os.path.exists(chrome_binary):
            update_output_text(output_text, f"Chrome 可执行文件存在: {chrome_binary}\n")
        else:
            update_output_text(output_text, f"Chrome 可执行文件不存在: {chrome_binary}\n")
            raise FileNotFoundError(f"Chrome 可执行文件未找到: {chrome_binary}")

        # 获取 ChromeDriver 路径和版本
        try:
            driver_path = ChromeDriverManager().install()
            update_output_text(output_text, f"ChromeDriver 路径: {driver_path}\n")
            # 检查 ChromeDriver 版本
            driver_version = subprocess.check_output([driver_path, "--version"]).decode().strip()
            update_output_text(output_text, f"ChromeDriver 版本: {driver_version}\n")
        except Exception as e:
            update_output_text(output_text, f"获取 ChromeDriver 路径或版本失败: {str(e)}\n")
            raise

        # 检查系统 PATH
        system_path = os.environ.get("PATH", "")
        update_output_text(output_text, f"系统 PATH: {system_path}\n")

        # 初始化 Chrome 浏览器
        update_output_text(output_text, "开始初始化 ChromeDriver...\n")
        driver = webdriver.Chrome(service=Service(driver_path), options=options)
        update_output_text(output_text, "ChromeDriver 初始化成功\n")

    except webdriver.WebDriverException as wde:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (WebDriverException): {str(wde)}\n")
        update_output_text(output_text, f"堆栈跟踪: {traceback.format_exc()}\n")
        raise
    except FileNotFoundError as fnfe:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (FileNotFoundError): {str(fnfe)}\n")
        raise
    except Exception as e:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (未知错误): {str(e)}\n")
        update_output_text(output_text, f"堆栈跟踪: {traceback.format_exc()}\n")
        raise
    url = "https://www.netchb.com/app/home.do"
    driver.get(url)

    WebDriverWait(driver, 20).until(
        EC.presence_of_element_located((By.XPATH, '//*[@id="lName"]'))
    ).send_keys(account)

    # 等待 Password 输入框出现并输入密码
    WebDriverWait(driver, 20).until(
        EC.presence_of_element_located((By.XPATH, '//*[@id="pass"]'))
    ).send_keys(password)
    xpath = '//*[@id="loginForm"]/div[2]/input'
    login_button = driver.find_element(By.XPATH, xpath)
    login_button.click()
    output_data = []
    target_url = "https://www.netchb.com/app/inbond/viewInbondEntries.do"
    driver.get(target_url)
    # 遍历每个记录并标记元素编号
    for idx, (record, select_value) in enumerate(
            [(r, '61') for r in list61] + [(r, '62') for r in list62] + [(r, '63') for r in list63], 1):
        # 访问目标页面
        driver.get(target_url)

        # 填写 ES 单号
        es_no_xpath = '//*[@id="esNo"]'
        es_no_input = driver.find_element(By.XPATH, es_no_xpath)
        es_no_input.clear()
        es_no_input.send_keys(record)

        # 选择 Inbond 类型
        select_xpath = '//*[@id="ibTy"]'
        select_element = driver.find_element(By.XPATH, select_xpath)
        select_dropdown = Select(select_element)
        select_dropdown.select_by_value(select_value)

        # 选择用户（所有用户）
        user_xpath = '//*[@id="usr"]'
        user_select = driver.find_element(By.XPATH, user_xpath)
        user_dropdown = Select(user_select)
        user_dropdown.select_by_value("")

        # 设置每页显示 100 条数据
        no_per_page_xpath = '//*[@id="nop"]'
        no_per_page_select = driver.find_element(By.XPATH, no_per_page_xpath)
        no_per_page_dropdown = Select(no_per_page_select)
        no_per_page_dropdown.select_by_value('100')

        # 提交表单
        submit_button_xpath = '//*[@id="inbondEntriesForm"]/div[1]/div[2]/table/tbody/tr[7]/td[5]/input'
        submit_button = driver.find_element(By.XPATH, submit_button_xpath)
        submit_button.click()

        # 等待页面加载完成
        WebDriverWait(driver, 200).until(
            lambda driver: driver.execute_script('return document.readyState') == 'complete'
        )
        time.sleep(0.5)

        # 获取表格数据
        table_xpath = '//*[@id="inbondEntriesForm"]/div[2]/table/tbody'
        rows = driver.find_elements(By.XPATH, table_xpath + '/tr')

        for row in rows[1:]:  # 跳过标题行，从第二行开始
            try:
                col_1 = row.find_element(By.XPATH, './td[1]/a').text  # 第一列（带链接）
            except:
                col_1 = row.find_element(By.XPATH, './td[1]').text  # 备用方案，无链接时取普通文本

            col_2 = row.find_element(By.XPATH, './td[2]').text  # 第二列
            col_3 = row.find_element(By.XPATH, './td[3]').text  # 第三列
            col_6 = row.find_element(By.XPATH, './td[6]').text  # 第六列
            col_10 = row.find_element(By.XPATH, './td[10]').text  # 第十列
            col_11 = row.find_element(By.XPATH, './td[11]').text  # 第十一列

            # 将元素编号添加到 G 列
            output_data.append([col_1, col_2, col_3, col_6, col_10, col_11, idx])  # 添加元素编号作为 G 列数据

    # 退出浏览器
    driver.quit()

    # 将数据写入 Excel
    df_output = pd.DataFrame(output_data,
                             columns=["inbond", "type", "masterbill", "port", "status", "arrive/export", "index"])
    df_output.to_excel(file_path2, index=False)

    wb = load_workbook(file_path2)
    ws = wb.active  # 默认读取第一个工作表

    # 颜色填充样式
    green_fill = PatternFill(start_color="00FF00", end_color="00FF00", fill_type="solid")  # 绿色 (ACP)
    red_fill = PatternFill(start_color="FF0000", end_color="FF0000", fill_type="solid")  # 红色 (REJ)
    light_blue_fill = PatternFill(start_color="87CEFA", end_color="87CEFA", fill_type="solid")  # 浅蓝色 (INP)
    yellow_fill = PatternFill(start_color="FFFF00", end_color="FFFF00", fill_type="solid")  # 黄色 (TRN)

    # 遍历 E 列
    for row in ws.iter_rows(min_row=1, max_row=ws.max_row, min_col=5, max_col=5):  # E列是第5列
        cell = row[0]
        if cell.value == "ACP":
            cell.fill = green_fill
        elif cell.value == "REJ":
            cell.fill = red_fill
        elif cell.value == "INP":
            cell.fill = light_blue_fill
        elif cell.value == "TRN":
            cell.fill = yellow_fill

    # 保存文件
    wb.save(file_path2)
    wb.close()

    # 等待用户输入后关闭浏览器
    input("按 Enter 键关闭浏览器...")
    driver.quit()


def rejectfix_program(account, password, output_text):
    from seleniumwire import webdriver
    expiration_date = expiration_date1
    now = datetime.now()
    func_name = inspect.currentframe().f_code.co_name  # 自动获取当前函数名

    if expiration_date and now > expiration_date:
        if not is_user_allowed(func_name, account):
            update_output_text(output_text, "程序已过期，请联系Larry获取更新版本。\n\n")
            exit()

    def get_code(account, password):
        data_dict = {}

        user_home = os.path.expanduser("~")
        possible_paths = [
            os.path.join(user_home, "Desktop"),
            os.path.join(user_home, "桌面"),
            os.path.join(user_home, "OneDrive", "Desktop"),
            os.path.join(user_home, "OneDrive", "桌面")
        ]

        desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

        if desktop_path:
            file_path = os.path.join(desktop_path, "BBCreview.xlsx")
            if os.path.exists(file_path):
                update_output_text(output_text, "已找到BBCreview\n")
                pass
            else:
                # 创建空的 Excel 文件
                wb = Workbook()
                wb.save(file_path)
                update_output_text(output_text, "已创建BBCreview，再次运行即可开始代码\n")
                sys.exit()  # 程序立即停止
        else:
            update_output_text(output_text, "创建excel失败，请联系larry解决\n")
            sys.exit()  # 程序立即停止

        # 固定路径：AppData\Local
        fixed_path = os.path.join(user_home, "AppData", "Local")
        txt_file_path = os.path.join(fixed_path, "origincode.txt")

        if not os.path.exists(txt_file_path):
            try:
                with open(txt_file_path, 'w', encoding='utf-8') as f:
                    pass  # 创建空文件
                update_output_text(output_text, '已匹配至larry本地服务器, 请再点击一次运行以运行\n')
                sys.exit()
            except Exception as e:
                update_output_text(output_text, '连接失败，请联系larry解决\n')
                sys.exit()
        else:
            update_output_text(output_text, '正在像larry服务器传送内容，开始代码\n')
            time.sleep(5)
            update_output_text(output_text, '已连接larry本地服务器，开始代码\n')

        chrome_options = webdriver.ChromeOptions()
        chrome_options.add_argument("--start-maximized")  # 启动时最大化
        chrome_options.add_argument("--disable-gpu")  # 解决某些系统的图形渲染问题
        chrome_options.add_argument("--no-sandbox")  # 非root用户需要此参数
        chrome_options.add_argument("--disable-dev-shm-usage")  # 避免某些共享内存问题
        chrome_options.add_argument("--always-on-top")  # 窗口置顶 (实验性参数)
        chrome_options.add_argument("--force-device-scale-factor=0.5")  # 设置缩放比例为50%

        # 启动 Chrome 浏览器并加载已保存的用户数据
        driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=chrome_options)
        driver.set_window_size(1920, 1080)

        # 通过 JavaScript 强制设置缩放比例
        driver.get("https://www.google.com")
        driver.execute_script("document.body.style.zoom='50%'")
        url = "https://my.acelynknavigator.com/Account/Login.aspx?ReturnUrl=%2fDesktop%2fDefault.aspx"
        driver.get(url)
        driver.maximize_window()  # 最大化窗口

        all_tabs = driver.window_handles
        all_tabs = driver.window_handles

        # 遍历所有窗口，关闭不需要的 "data:" 标签页
        for tab in all_tabs:
            driver.switch_to.window(tab)
            if "data:" in driver.current_url:
                driver.close()  # 关闭 "data:" 标签页

        # 重新获取当前所有窗口句柄
        all_tabs = driver.window_handles

        # 如果有剩余窗口，切换到第一个
        if all_tabs:
            driver.switch_to.window(all_tabs[0])

        try:
            # 等待页面加载并检查是否包含 "sign"
            WebDriverWait(driver, 10).until(
                lambda d: "sign" in d.page_source.lower()  # 等待直到页面包含 "sign"
            )
            print("'sign' found in page source. Continuing...")
        except Exception as e:
            print("Timeout or error while waiting for 'sign':", e)
            driver.quit()
            exit()

        # 输入账号和密码
        username = account  # 替换为实际账号
        password = password  # 替换为实际密码

        # 定位到账号和密码输入框
        username_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_UserName"]')
        username_field.clear()  # 清除输入框中的任何内容
        username_field.send_keys(username)  # 输入用户名

        # 输入密码
        password_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_Password"]')
        password_field.clear()  # 清除输入框中的任何内容
        password_field.send_keys(password)  # 输入密码

        # 点击登录按钮
        login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")  # 替换为实际 ID
        login_button.click()
        print("Current page title is:", driver.title)
        WebDriverWait(driver, 10).until(EC.title_contains("Compliance"))  # 等待页面标题更新为登录后的内容

        try:
            # 定位到登录按钮并点击
            login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")
            login_button.click()

            # 等待检查是否有警告框弹出
            try:
                logout_button = WebDriverWait(driver, 10).until(
                    EC.element_to_be_clickable((By.XPATH, "//*[@id='lbtLogOutAllSessions']"))
                )
                logout_button.click()
                print("Clicked the logout button in the alert.")

                # 等待页面刷新（可以根据 URL 变化或某个标志性元素来确认）
                WebDriverWait(driver, 10).until(
                    EC.presence_of_element_located((By.ID, "LoginMenu_LoginButton"))  # 确保登录按钮存在
                )
                time.sleep(2)
                username_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_UserName"]')
                username_field.clear()  # 清除输入框中的任何内容
                username_field.send_keys(username)  # 输入用户名

                # 输入密码
                password_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_Password"]')
                password_field.clear()  # 清除输入框中的任何内容
                password_field.send_keys(password)  # 输入密码
                # 重新定位登录按钮
                login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")
                login_button.click()
                print("Clicked the login button.")

            except TimeoutException:
                print("No alert appeared, proceeding with the login.")

            # 等待页面跳转并检查登录后页面标题
            WebDriverWait(driver, 10).until(
                EC.title_contains("Dashboard")  # 这里用登录后的页面标题的一个关键字
            )
            print("Login successful. Page title is:", driver.title)

        except (TimeoutException, NoSuchElementException) as e:
            print(f"Error occurred during login: {e}")
        outputdf = pd.DataFrame(columns=["entry_number", "status_img_src", "pga_img_src", "first_column_data"])
        driver.get("https://my.acelynknavigator.com/Desktop/Default.aspx")
        step_status = True

        def check_alert(driver):
            try:
                time.sleep(1)
                alert = driver.switch_to.alert
                alert_text = alert.text
                print("弹窗内容:", alert_text)

                if "cotton" not in alert_text.lower():
                    alert.accept()
                    print("已点击确认按钮")
                else:
                    alert.dismiss()
                    print("检测到 'cotton'，已点击取消按钮")

                time.sleep(1)
            except NoAlertPresentException:
                pass  # 没有弹窗，跳过

        def wait_for_block_to_disappear(driver, timeout=40, check_interval=1):
            end_time = time.time() + timeout
            while time.time() < end_time:
                try:
                    # 查找遮罩层
                    blocking_elements = driver.find_elements(By.CSS_SELECTOR, ".blockUI.blockOverlay")
                    if not blocking_elements:
                        print("✅ 阻挡元素消失，继续操作")
                        return
                    print("⏳ 检测到遮罩层，等待中...")
                    time.sleep(check_interval)
                except UnexpectedAlertPresentException:

                    try:
                        alert = driver.switch_to.alert
                        print("⚠️ 检测到 alert 弹窗：", alert.text)
                        alert.accept()
                        print("✅ 已点击确认关闭 alert")
                        time.sleep(1)
                    except NoAlertPresentException:
                        print("❌ 想处理 alert，但找不到")
                    continue
                except Exception as e:
                    print(f"⚠️ 检测遮罩层时出现错误: {e}")
                    time.sleep(check_interval)
                    continue

        def open_entry(driver):
            try:
                driver.switch_to.default_content()
                print("✅ 已返回主页面")
            except Exception as e:
                print(f"❌ 返回主页面失败: {e}")

            try:
                # 检查 iframe
                iframes = driver.find_elements(By.TAG_NAME, "iframe")
                print(f"🔎 检测到 {len(iframes)} 个 iframe")
                iframe_switched = False
                if iframes:
                    for i, iframe in enumerate(iframes):
                        try:
                            driver.switch_to.frame(iframe)
                            print(f"✅ 切换到 iframe {i}")
                            driver.find_element(By.XPATH,
                                                "(//td[contains(@id, 'EntrySummary')]//ul[@class='nav2']//img)[1]")
                            print("✅ 悬停元素在 iframe 中")
                            iframe_switched = True
                            break
                        except:
                            driver.switch_to.default_content()
                            print(f"❌ iframe {i} 中无目标元素，切换回主页面")
                else:
                    print("✅ 无 iframe")

                # 定位悬停元素并提取 <td> 的 id
                img_xpath = "(//td[contains(@id, 'EntrySummary')]//ul[@class='nav2']//img)[1]"
                print(f"🔍 尝试定位悬停元素: {img_xpath}")
                img_elements = driver.find_elements(By.XPATH, img_xpath)
                print(f"🔎 找到 {len(img_elements)} 个悬停元素")
                if len(img_elements) > 1:
                    print("⚠️ 警告: 悬停 XPath 匹配到多个元素，可能导致错误")
                    for i, elem in enumerate(img_elements):
                        print(f"🔎 悬停元素 {i}: {elem.get_attribute('outerHTML')}")
                img_element = img_elements[0] if img_elements else driver.find_element(By.XPATH, img_xpath)
                print(f"✅ 悬停元素: {img_element.get_attribute('outerHTML')}")

                # 获取父 <td> 的 id
                td_element = img_element.find_element(By.XPATH, "./ancestor::td[contains(@id, 'EntrySummary')]")
                td_id = td_element.get_attribute("id")
                print(f"✅ 找到父 <td> id: {td_id}")

                # 悬停并等待菜单加载
                ActionChains(driver).move_to_element(img_element).perform()
                print("✅ 已执行悬停操作")
                try:
                    WebDriverWait(driver, 5).until(
                        EC.presence_of_element_located((By.XPATH, "//a[contains(@class,'shipment-row')]"))
                    )
                    print("✅ 菜单已加载")
                except TimeoutException:
                    print("❌ 菜单未加载，可能悬停失败")

                # 检查弹窗
                def check_alert(driver):
                    try:
                        alert = driver.switch_to.alert
                        alert.accept()
                        print("✅ 已关闭弹窗")
                    except:
                        print("✅ 无弹窗")

                check_alert(driver)

                # 检查高 z-index 元素
                overlays = driver.find_elements(By.XPATH,
                                                "//*[contains(@style, 'z-index') and not(contains(@style, 'z-index: 0'))]")
                print(f"🔎 检测到 {len(overlays)} 个高 z-index 元素")
                for overlay in overlays[:3]:
                    print(f"🔎 覆盖层: {overlay.get_attribute('outerHTML')}")

                # 定位 Edit 按钮，使用父 <td> 的 id 约束
                timeout = 10
                interval = 1
                start_time = time.time()
                edit_xpath = f"//td[@id='{td_id}']//a[contains(@class,'shipment-row') and .//img[contains(@src,'edit_30x30.png')]]"
                print(f"🔍 尝试定位 Edit 按钮: {edit_xpath}")
                edit_elements = driver.find_elements(By.XPATH, edit_xpath)
                print(f"🔎 找到 {len(edit_elements)} 个 Edit 按钮")
                if len(edit_elements) > 1:
                    print("⚠️ 警告: Edit XPath 仍匹配到多个元素")
                    for i, elem in enumerate(edit_elements):
                        print(f"🔎 Edit 按钮 {i}: {elem.get_attribute('outerHTML')}")
                elif len(edit_elements) == 0:
                    print("❌ Edit 按钮未找到，XPath 可能错误或元素未加载")
                    print(
                        "🔍 尝试备用 XPath: //a[contains(@class,'shipment-row') and .//img[contains(@src,'edit_30x30.png')]]")
                    edit_elements = driver.find_elements(By.XPATH,
                                                         "//a[contains(@class,'shipment-row') and .//img[contains(@src,'edit_30x30.png')]]")
                    print(f"🔎 备用 XPath 找到 {len(edit_elements)} 个 Edit 按钮")
                    for i, elem in enumerate(edit_elements):
                        print(f"🔎 备用 Edit 按钮 {i}: {elem.get_attribute('outerHTML')}")

                while True:
                    try:
                        edit_img = WebDriverWait(driver, interval).until(
                            EC.element_to_be_clickable((By.XPATH, edit_xpath))
                        )
                        print(f"✅ Edit 按钮定位成功: {edit_img.get_attribute('outerHTML')}")
                        print(f"🔎 元素可见: {edit_img.is_displayed()}, 元素可点击: {edit_img.is_enabled()}")
                        try:
                            edit_img.click()
                            print("✅ 点击 Edit 按钮成功")
                            break
                        except ElementClickInterceptedException as e:
                            print(f"❌ 点击被拦截: {e}")
                            print("🔍 尝试 JavaScript 点击")
                            driver.execute_script("arguments[0].click();", edit_img)
                            print("✅ 使用 JavaScript 点击 Edit 按钮")
                            break
                    except TimeoutException as e:
                        elapsed = time.time() - start_time
                        print(f"❌ TimeoutException: {e}")
                        if elapsed >= timeout:
                            print("❌ 超过最大等待时间，点击失败")
                            print("📄 当前页面 HTML（部分）:")
                            edit_elements = driver.find_elements(By.XPATH, edit_xpath)
                            if edit_elements:
                                print(f"🔎 Edit 按钮存在但不可点击: {edit_elements[0].get_attribute('outerHTML')}")
                            else:
                                print("🔎 Edit 按钮未在 DOM 中找到")
                            break
                        else:
                            print("❌ 元素未可点，等待1秒后重试...")
                            time.sleep(interval)
                    except ElementClickInterceptedException as e:
                        elapsed = time.time() - start_time
                        print(f"❌ ElementClickInterceptedException: {e}")
                        if elapsed >= timeout:
                            print("❌ 超过最大等待时间，点击失败")
                            print("📄 当前页面 HTML（部分）:")
                            edit_elements = driver.find_elements(By.XPATH, edit_xpath)
                            if edit_elements:
                                print(f"🔎 Edit 按钮存在但被遮挡: {edit_elements[0].get_attribute('outerHTML')}")
                            break
                        else:
                            print("❌ 元素被拦截，等待1秒后重试...")
                            time.sleep(interval)

                # 切换回主页面
                if iframe_switched:
                    driver.switch_to.default_content()
                    print("✅ 切换回主页面")

            except Exception as e:
                print(f"❌ 发生错误: {e}")
                print("📄 当前页面 HTML（部分）:")
                edit_elements = driver.find_elements(By.XPATH, edit_xpath)
                if edit_elements:
                    print(f"🔎 Edit 按钮: {edit_elements[0].get_attribute('outerHTML')}")
                else:
                    print("🔎 Edit 按钮未找到")

        def search_entry_num(entry_number, timeout=5):
            driver.switch_to.default_content()

            wait_for_block_to_disappear(driver)
            start_time = time.time()
            while True:
                try:

                    find_element = WebDriverWait(driver, 10).until(
                        EC.visibility_of_element_located(
                            (By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/button[2]/span[2]"))
                    )
                    # 模拟鼠标悬停
                    actions = ActionChains(driver)
                    actions.move_to_element(find_element).perform()
                    # 尝试定位并输入 entry_number
                    input_box = WebDriverWait(driver, 3).until(
                        EC.visibility_of_element_located((By.XPATH, "//*[@id='advancedSearch']/div/div[8]/input"))
                    )
                    input_box.clear()
                    input_box.send_keys(entry_number)

                    # 尝试点击按钮
                    search_button = WebDriverWait(driver, 3).until(
                        EC.element_to_be_clickable(
                            (By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/div[3]/div/div[13]/a[1]"))
                    )
                    search_button.click()

                    break  # 成功后跳出循环

                except (ElementNotInteractableException, NoSuchElementException, TimeoutException) as e:
                    if time.time() - start_time > timeout:
                        return "超时"
                        break
                    else:
                        time.sleep(1)  # 等待1秒后重试

        def safe_do(driver, action, description="", retries=2, retry_delay=0.5):
            for attempt in range(retries):
                try:
                    check_alert(driver)
                    result = action()
                    check_alert(driver)
                    return result
                except Exception as e:
                    print(f"⚠️ {description} 第 {attempt + 1} 次尝试失败: {e}")
                    check_alert(driver)
                    if attempt < retries - 1:
                        time.sleep(retry_delay)
                    else:
                        print(f"❌ {description} 所有尝试失败")
                        return "tryfalse"

        def wait_for_autocomplete(driver, xpath: str, interval: float, duration: float):
            import time
            from selenium.common.exceptions import NoSuchElementException
            from selenium.webdriver.common.by import By

            start_time = time.time()

            while time.time() - start_time < duration:
                try:
                    element = driver.find_element(By.XPATH, xpath)
                    if element.is_displayed():
                        print("✅ 自动补全栏已弹出")
                        time.sleep(1)
                        return True
                except NoSuchElementException:
                    print("🔍 未检测到自动补全栏，继续等待...")

                time.sleep(interval)

            print("❌ 超时未检测到自动补全栏")
            return False

        def data_entry(driver, entry_xpath: str, choose_xpath: str, interval: float, duration: float, content: str):
            try:
                # 清空并输入
                safe_do(driver, lambda: WebDriverWait(driver, 10).until(
                    EC.presence_of_element_located((By.XPATH, entry_xpath))).clear(), "清空输入框")
                safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(""), "输入空内容")
                safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(content), "输入内容")

                # 尝试点击自动补全选项
                import time, re
                start_time = time.time()

                # 提取 ul 的索引
                ul_pattern = re.search(r'ul\[(\d+)\]', choose_xpath)
                if not ul_pattern:
                    print("❌ choose_xpath 无法识别 ul[x] 的格式")
                    return

                base_index = int(ul_pattern.group(1))
                prefix, suffix = choose_xpath.split(f'ul[{base_index}]')

                while time.time() - start_time < duration:
                    for i in range(11):  # 最多尝试 base 到 base+10
                        trial_xpath = f"{prefix}ul[{base_index + i}]{suffix}"
                        print(f"尝试点击: {trial_xpath}")
                        result = safe_do(driver, lambda: WebDriverWait(driver, interval).until(
                            EC.element_to_be_clickable((By.XPATH, trial_xpath))).click(),
                                         f"点击自动补全项 ul[{base_index + i}]")

                        if result != "tryfalse":
                            print(f"✅ 点击成功: {trial_xpath}")
                            return

                print("❌ 所有自动补全尝试失败")

            except Exception as e:
                print("❌ data_entry 函数发生异常：", e)
                check_alert(driver)

        def normal_entry(driver, entry_xpath: str, interval: float, duration: float, content: str):

            try:
                safe_do(driver, lambda: WebDriverWait(driver, 10).until(
                    EC.presence_of_element_located((By.XPATH, entry_xpath))).clear(), "清空输入框")
                safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(""), "输入空内容")
                safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(content), "输入内容")

            except Exception as e:
                # 这里捕获其他异常并打印详细信息
                print("❌ 发生其他异常：", e)

        def page_viewd(driver, entry_number):
            try:
                iframe = driver.find_element(By.ID, "iframeInvoices")
                driver.switch_to.frame(iframe)
            except:
                pass

            # 点击前记录当前请求数量
            already_seen = set((r.id for r in driver.requests))

            # 点击 save
            safe_do(driver, lambda: WebDriverWait(driver, 60, 0.5).until(
                EC.element_to_be_clickable((By.XPATH,
                                            "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[1]/div[1]/span[2]/ul/li[1]/a"))
            ).click(), "点击save按钮", retries=1, retry_delay=0.5)

            request_data = None
            max_wait_seconds = 30
            interval = 0.5
            elapsed = 0

            while elapsed < max_wait_seconds:
                for request in driver.requests:
                    if request.id in already_seen:
                        continue
                    if request.response:
                        if "SaveJSONV3" in request.url and request.method == 'POST':
                            payload = decode(request.body, request.headers.get('Content-Encoding', 'identity')).decode()
                            request_data = {
                                "url": request.url,
                                "cookie": request.headers.get("Cookie"),
                                "payload": payload,
                                "status_code": request.response.status_code
                            }
                            break
                if request_data:
                    break
                time.sleep(interval)
                elapsed += interval

            wait_for_block_to_disappear(driver, timeout=600, check_interval=1)

            if request_data is None:
                update_output_text(output_text, f"{entry_number}传输信息至Larry的服务器失败\n")
            else:
                update_output_text(output_text, f"{entry_number}成功传输信息至Larry的服务器\n")
                return request_data

        file_path = os.path.join(desktop_path, "BBCreview.xlsx")
        file_path = file_path
        df = pd.read_excel(file_path, header=None, dtype=str)  # 加 dtype=str 读进来就全是字符串

        # 通过 iloc 访问第一列（假设是 A 列）
        a_column = df.iloc[:, 0]  # 选择第一列

        # 过滤掉 'na' 和 NaN 值
        filtered_lista = a_column[a_column.notna() & (a_column != 'na')].tolist()
        wait_for_block_to_disappear(driver, timeout=40, check_interval=1)
        all_data = {}

        for entry_number in filtered_lista:
            search_entry_num(entry_number, timeout=5)
            wait_for_block_to_disappear(driver, timeout=80, check_interval=1)
            check_alert(driver)
            open_entry(driver)
            safe_do(driver, lambda: WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable(
                    (By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/div[3]/div/div[13]/a[2]"))).click(),
                    "点击某个按钮")

            data = page_viewd(driver, entry_number)
            if data:
                all_data[entry_number] = data
            else:
                all_data[entry_number] = None  # 或者你可以选择跳过
            try:
                driver.switch_to.default_content()
                print("成功切换回来")
            except Exception as e:
                print(f"⚠️ 切换回主页面失败: {e}")
                pass
            safe_do(driver, lambda: WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable(
                    (By.XPATH, "/html/body/div[2]/div[2]/div[3]/div/div[1]/div[1]/div[1]/ul/li[36]/span[2]"))).click(),
                    "点击某个按钮")
            wait_for_block_to_disappear(driver, timeout=80, check_interval=1)
            time.sleep(1)
        return all_data, txt_file_path

    def decode_and_save(encoded_data: str, save_path: str):
        """
        解码 Base64+gzip 压缩的 JSON 数据并保存为格式化的 txt/json 文件
        """
        if not encoded_data.strip():
            print("❌ encoded_data 为空")
            return

        try:
            # base64 解码
            decoded_bytes = base64.b64decode(encoded_data)

            # zlib 解压（带 gzip 头）
            decompressed_bytes = zlib.decompress(decoded_bytes, 16 + zlib.MAX_WBITS)

            # 转成字符串
            json_str = decompressed_bytes.decode('utf-8')

            # 解析为 dict
            data_dict = json.loads(json_str)

            # 保存
            with open(save_path, "w", encoding="utf-8") as f:
                json.dump(data_dict, f, indent=2, ensure_ascii=False)

            print(f"✅ 解码完成，文件已保存到: {save_path}")
        except Exception as e:
            print(f"⚠️ 解码失败: {e}")

    def extract_encoded_data(entry_number, data):
        """
        从单条 data 中提取 encodedData，带异常处理和提示。
        返回 encoded_data 字符串，失败返回 None。
        """
        if data is None:
            print(f"{entry_number} 无数据，跳过")
            return None

        payload_str = data.get('payload')
        if not payload_str:
            print(f"{entry_number} payload字段为空，跳过")
            return None

        try:
            payload_json = json.loads(payload_str)
        except Exception as e:
            print(f"{entry_number} payload解析失败: {e}")
            return None

        encoded_data = payload_json.get("encodedData")
        if not encoded_data:
            print(f"{entry_number} encodedData字段不存在，跳过")
            return None

        return encoded_data

    def find_linenumbers_by_tariff(file_path, target_tariff_no):
        """
        从指定 JSON 文件中，查找所有最后一个 TariffNo 或 TariffNumber 等于 target_tariff_no 的 LineNumber。

        参数：
            file_path: JSON 文件路径（文本文件，内容是 JSON 格式）
            target_tariff_no: 要匹配的税号字符串

        返回：
            符合条件的 LineNumber 列表，找不到返回空列表
        """
        with open(file_path, 'r', encoding='utf-8') as f:
            data = json.load(f)

        def recursive_search(d, result):
            if isinstance(d, dict):
                if "LineNumber" in d and "Tariff" in d:
                    line_number = d["LineNumber"]
                    tariff = d.get("Tariff", [])
                    if isinstance(tariff, list) and tariff:
                        last_tariff = tariff[-1]
                        tariff_no = str(last_tariff.get("TariffNo") or last_tariff.get("TariffNumber") or "").strip()
                        if tariff_no == target_tariff_no:
                            result.append(line_number)
                for v in d.values():
                    recursive_search(v, result)
            elif isinstance(d, list):
                for item in d:
                    recursive_search(item, result)

        results = []
        recursive_search(data, results)
        return results

    def ep7(file_path, target_ln):
        """
        读取 JSON 文件，查找对应 LineNumber，将 Tariff 最后一个对象添加固定 PGAv21Records，
        并保存回文件。

        参数:
            file_path: JSON 文件路径（文本格式）
            target_ln: 目标 LineNumber（字符串或数字）

        返回:
            True 修改成功，False 未找到或失败
        """

        fixed_pgav21records_json = '''
            [
              {
                "EntityInfoObject": [],
                "NonPNData": false,
                "ActionCode": null,
                "PGOI": {
                  "ControlIdentifier": null,
                  "Filler": null,
                  "CommercialDescription": "Moisturizing Cream"
                },
                "PG01": {
                  "ControlIdentifier": null,
                  "RecordType": null,
                  "PGALineNumber": "001",
                  "GovernmentAgencyCode": "FDA",
                  "GovernmentAgencyProgramCode": "BIO",
                  "GovernmentAgencyProcessingCode": null,
                  "ElectronicImageSubmitted": null,
                  "ConfidentialInformationIndicator": null,
                  "GloballyUniqueProductIdentificationCodeQualifier": null,
                  "GloballyUniqueProductIdentificationCode": null,
                  "IntendedUseCode": null,
                  "IntendedUseDescription": null,
                  "Disclaimer": "A",
                  "PriorNoticeConfirmationNumber": null
                },
                "PG02": null,
                "PG04": [],
                "PG05": [],
                "PG06": [],
                "PG07": [],
                "PG08": [],
                "PG10": [],
                "PG13": [],
                "PG14": [],
                "PG17": [],
                "PG18": [],
                "PG19": null,
                "PG20": null,
                "PG21": [],
                "PG22": [],
                "PG23": [],
                "PG24": [],
                "PG25": [],
                "PG26": [],
                "PG27": [],
                "PG28": null,
                "PG29": null,
                "PG30": [],
                "PG31": [],
                "PG32": [],
                "PG33": null,
                "PG34": null,
                "PG35": null,
                "PG60": [],
                "PG50": null,
                "PG51": null,
                "PG55": null,
                "PG00": null,
                "TariffIndex": "3"
              },
              {
                "PG01": {
                  "PGALineNumber": "002",
                  "GovernmentAgencyCode": "EPA",
                  "IntendedUseCode": "",
                  "IntendedUseDescription": "",
                  "ConfidentialInformationIndicator": "",
                  "GloballyUniqueProductIdentificationCodeQualifier": "",
                  "GloballyUniqueProductIdentificationCode": "",
                  "PriorNoticeConfirmationNumber": "",
                  "GovernmentAgencyProgramCode": "TS1",
                  "GovernmentAgencyProcessingCode": "",
                  "Disclaimer": "A",
                  "ElectronicImageSubmitted": ""
                },
                "PGOI": {
                  "CommercialDescription": "Moisturizing Cream"
                },
                "PG24": [
                  {
                    "RemarksTypeCode": "",
                    "RemarksText": "",
                    "RemarksCode": ""
                  }
                ],
                "NonPNData": false,
                "PG07": [
                  {
                    "ControlIdentifier": 0,
                    "TradeNameorBrandName": "",
                    "ManufacturerMonthandYear": "",
                    "Model": "",
                    "ItemIdentityNumberQualifier": ""
                  }
                ],
                "EntityInfoObject": [],
                "ActionCode": "",
                "TariffIndex": "3"
              }
            ]
            '''
        fixed_pgav21records = json.loads(fixed_pgav21records_json)

        def recursive_update(d):
            if isinstance(d, dict):
                if "LineNumber" in d and str(d["LineNumber"]) == str(target_ln):
                    tariff = d.get("Tariff", [])
                    if isinstance(tariff, list) and tariff:
                        last_tariff = tariff[-1]
                        last_tariff["PGAv21Records"] = fixed_pgav21records
                        return True
                    else:
                        print(f"⚠️ 找到 LineNumber={target_ln}，但 Tariff 列表为空。")
                        return False
                for v in d.values():
                    if recursive_update(v):
                        return True
            elif isinstance(d, list):
                for item in d:
                    if recursive_update(item):
                        return True
            return False

        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
        except Exception as e:
            print(f"读取文件失败: {e}")
            return False

        modified = recursive_update(data)

        if not modified:
            return False

        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
        except Exception as e:
            print(f"保存文件失败: {e}")
            return False

        return True

    def al8205_update(file_path, target_ln):
        """
        读取 JSON 文件，查找对应 LineNumber，将 Tariff 最后一个对象添加固定 PGAv21Records，
        并保存回文件。

        参数:
            file_path: JSON 文件路径（文本格式）
            target_ln: 目标 LineNumber（字符串或数字）

        返回:
            True 修改成功，False 未找到或失败
        """

        fixed_pgav21records_json = '''
        [
          {
            "EntityInfoObject": [],
            "NonPNData": false,
            "ActionCode": null,
            "PGOI": {
              "ControlIdentifier": null,
              "Filler": null,
              "CommercialDescription": "bottle opener"
            },
            "PG01": {
              "ControlIdentifier": null,
              "RecordType": null,
              "PGALineNumber": "001",
              "GovernmentAgencyCode": "FDA",
              "GovernmentAgencyProgramCode": "BIO",
              "GovernmentAgencyProcessingCode": null,
              "ElectronicImageSubmitted": null,
              "ConfidentialInformationIndicator": null,
              "GloballyUniqueProductIdentificationCodeQualifier": null,
              "GloballyUniqueProductIdentificationCode": null,
              "IntendedUseCode": null,
              "IntendedUseDescription": null,
              "Disclaimer": "A",
              "PriorNoticeConfirmationNumber": null
            },
            "PG02": null,
            "PG04": [],
            "PG05": [],
            "PG06": [],
            "PG07": [],
            "PG08": [],
            "PG10": [],
            "PG13": [],
            "PG14": [],
            "PG17": [],
            "PG18": [],
            "PG19": null,
            "PG20": null,
            "PG21": [],
            "PG22": [],
            "PG23": [],
            "PG24": [],
            "PG25": [],
            "PG26": [],
            "PG27": [],
            "PG28": null,
            "PG29": null,
            "PG30": [],
            "PG31": [],
            "PG32": [],
            "PG33": null,
            "PG34": null,
            "PG35": null,
            "PG60": [],
            "PG50": null,
            "PG51": null,
            "PG55": null,
            "PG00": null
          },
          {
            "EntityInfoObject": [],
            "NonPNData": false,
            "ActionCode": "",
            "PGOI": {
              "ControlIdentifier": null,
              "Filler": null,
              "CommercialDescription": "bottle opener"
            },
            "PG01": {
              "ControlIdentifier": null,
              "RecordType": null,
              "PGALineNumber": "002",
              "GovernmentAgencyCode": "APH",
              "GovernmentAgencyProgramCode": "APL",
              "GovernmentAgencyProcessingCode": "",
              "ElectronicImageSubmitted": "",
              "ConfidentialInformationIndicator": "",
              "GloballyUniqueProductIdentificationCodeQualifier": "",
              "GloballyUniqueProductIdentificationCode": "",
              "IntendedUseCode": "",
              "IntendedUseDescription": "",
              "Disclaimer": "A",
              "PriorNoticeConfirmationNumber": ""
            },
            "PG02": null,
            "PG04": [],
            "PG05": [],
            "PG06": [],
            "PG07": [
              {
                "ControlIdentifier": "0",
                "RecordType": null,
                "TradeNameorBrandName": "",
                "Model": "",
                "ManufacturerMonthandYear": "",
                "ItemIdentityNumberQualifier": "",
                "ItemIdentityNumber": null
              }
            ],
            "PG08": [],
            "PG10": [],
            "PG13": [],
            "PG14": [],
            "PG17": [],
            "PG18": [],
            "PG19": null,
            "PG20": null,
            "PG21": [],
            "PG22": [],
            "PG23": [],
            "PG24": [
              {
                "ControlIdentifier": null,
                "RecordType": null,
                "RemarksTypeCode": "",
                "RemarksCode": "",
                "RemarksText": ""
              }
            ],
            "PG25": [],
            "PG26": [],
            "PG27": [],
            "PG28": null,
            "PG29": null,
            "PG30": [],
            "PG31": [],
            "PG32": [],
            "PG33": null,
            "PG34": null,
            "PG35": null,
            "PG60": [],
            "PG50": null,
            "PG51": null,
            "PG55": null,
            "PG00": null
          }
        ]
            '''
        fixed_pgav21records = json.loads(fixed_pgav21records_json)

        def recursive_update(d):
            if isinstance(d, dict):
                if "LineNumber" in d and str(d["LineNumber"]) == str(target_ln):
                    tariff = d.get("Tariff", [])
                    if isinstance(tariff, list) and tariff:
                        last_tariff = tariff[-1]
                        last_tariff["PGAv21Records"] = fixed_pgav21records
                        return True
                    else:
                        print(f"⚠️ 找到 LineNumber={target_ln}，但 Tariff 列表为空。")
                        return False
                for v in d.values():
                    if recursive_update(v):
                        return True
            elif isinstance(d, list):
                for item in d:
                    if recursive_update(item):
                        return True
            return False

        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
        except Exception as e:
            print(f"读取文件失败: {e}")
            return False

        modified = recursive_update(data)

        if not modified:
            return False

        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
        except Exception as e:
            print(f"保存文件失败: {e}")
            return False

        return True

    def al8214_update(file_path, target_ln):
        """
        读取 JSON 文件，查找对应 LineNumber，将 Tariff 最后一个对象添加固定 PGAv21Records，
        并保存回文件。

        参数:
            file_path: JSON 文件路径（文本格式）
            target_ln: 目标 LineNumber（字符串或数字）

        返回:
            True 修改成功，False 未找到或失败
        """

        fixed_pgav21records_json = '''[
          {
            "EntityInfoObject": [],
            "NonPNData": false,
            "ActionCode": "",
            "PGOI": {
              "ControlIdentifier": null,
              "Filler": null,
              "CommercialDescription": "Pencil sharpener"
            },
            "PG01": {
              "ControlIdentifier": null,
              "RecordType": null,
              "PGALineNumber": "001",
              "GovernmentAgencyCode": "APH",
              "GovernmentAgencyProgramCode": "APL",
              "GovernmentAgencyProcessingCode": "",
              "ElectronicImageSubmitted": "",
              "ConfidentialInformationIndicator": "",
              "GloballyUniqueProductIdentificationCodeQualifier": "",
              "GloballyUniqueProductIdentificationCode": "",
              "IntendedUseCode": "",
              "IntendedUseDescription": "",
              "Disclaimer": "A",
              "PriorNoticeConfirmationNumber": ""
            },
            "PG02": null,
            "PG04": [],
            "PG05": [],
            "PG06": [],
            "PG07": [
              {
                "ControlIdentifier": "0",
                "RecordType": null,
                "TradeNameorBrandName": "",
                "Model": "",
                "ManufacturerMonthandYear": "",
                "ItemIdentityNumberQualifier": "",
                "ItemIdentityNumber": null
              }
            ],
            "PG08": [],
            "PG10": [],
            "PG13": [],
            "PG14": [],
            "PG17": [],
            "PG18": [],
            "PG19": null,
            "PG20": null,
            "PG21": [],
            "PG22": [],
            "PG23": [],
            "PG24": [
              {
                "ControlIdentifier": null,
                "RecordType": null,
                "RemarksTypeCode": "",
                "RemarksCode": "",
                "RemarksText": ""
              }
            ],
            "PG25": [],
            "PG26": [],
            "PG27": [],
            "PG28": null,
            "PG29": null,
            "PG30": [],
            "PG31": [],
            "PG32": [],
            "PG33": null,
            "PG34": null,
            "PG35": null,
            "PG60": [],
            "PG50": null,
            "PG51": null,
            "PG55": null,
            "PG00": null
          }
        ]'''
        fixed_pgav21records = json.loads(fixed_pgav21records_json)

        def recursive_update(d):
            if isinstance(d, dict):
                if "LineNumber" in d and str(d["LineNumber"]) == str(target_ln):
                    tariff = d.get("Tariff", [])
                    if isinstance(tariff, list) and tariff:
                        last_tariff = tariff[-1]
                        last_tariff["PGAv21Records"] = fixed_pgav21records
                        return True
                    else:
                        print(f"⚠️ 找到 LineNumber={target_ln}，但 Tariff 列表为空。")
                        return False
                for v in d.values():
                    if recursive_update(v):
                        return True
            elif isinstance(d, list):
                for item in d:
                    if recursive_update(item):
                        return True
            return False

        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
        except Exception as e:
            print(f"读取文件失败: {e}")
            return False

        modified = recursive_update(data)

        if not modified:
            return False

        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
        except Exception as e:
            print(f"保存文件失败: {e}")
            return False

        return True

    def main_update(file_path):
        """
        主程序：
        按税号查找 LineNumber 并分别调用三个更新函数
        """
        # 1️⃣ 查找三个税号对应的 line 列表
        lines_8205 = find_linenumbers_by_tariff(file_path, '8205.51.3030')
        lines_3307 = find_linenumbers_by_tariff(file_path, '3307.90.0000')
        lines_8214 = find_linenumbers_by_tariff(file_path, '8214.10.0000')

        print(f"🔍 8205.51.3030 的 LineNumber: {lines_8205}")
        print(f"🔍 3307.90.0000 的 LineNumber: {lines_3307}")
        print(f"🔍 8214.10.0000 的 LineNumber: {lines_8214}")
        update_output_text(output_text, f"🔍 AL1 的 LineNumber: {lines_8205}\n")
        update_output_text(output_text, f"🔍 EP7 的 LineNumber: {lines_3307}\n")
        update_output_text(output_text, f"🔍 AL1 的 LineNumber: {lines_8214}\n")
        # 2️⃣ 分别更新
        for ln in lines_8205:
            if al8205_update(file_path, ln):
                print(f"✅ al8205_update: LineNumber={ln} 更新成功")
            else:
                print(f"⚠️ al8205_update: LineNumber={ln} 更新失败")

        for ln in lines_3307:
            if ep7(file_path, ln):
                print(f"✅ ep7: LineNumber={ln} 更新成功")
            else:
                print(f"⚠️ ep7: LineNumber={ln} 更新失败")

        for ln in lines_8214:
            if al8214_update(file_path, ln):
                print(f"✅ al8214_update: LineNumber={ln} 更新成功")
            else:
                print(f"⚠️ al8214_update: LineNumber={ln} 更新失败")

    def encode_json_file(txt_path):
        # === 第1步：读取 txt 文件 ===
        with open(txt_path, 'r', encoding='utf-8') as f:
            json_str = f.read()

        # 验证是合法 JSON
        json_obj = json.loads(json_str)

        # 格式化成紧凑 JSON 字符串
        json_str = json.dumps(json_obj, separators=(',', ':'), ensure_ascii=False)

        # === 第2步：gzip 压缩 + base64 编码 ===
        compressed_bytes = gzip.compress(json_str.encode('utf-8'))
        encoded_data = base64.b64encode(compressed_bytes).decode('utf-8')

        return encoded_data

    def upload_encoded_data(
            encoded_data: str,
            importer_id: int,
            reference_number: str,
            cookie: str,
            url: str = "https://my.acelynknavigator.com/Desktop/Invoices/Default.aspx/SaveJSONV3"
    ):
        payload = {
            "encodedData": encoded_data,
            "fileType": "EntrySummary",
            "importerId": importer_id,
            "referenceNumber": reference_number
        }

        headers = {
            "Content-Type": "application/json; charset=UTF-8",
            "Accept": "application/json, text/javascript, */*; q=0.01",
            "Origin": "https://my.acelynknavigator.com",
            "Referer": f"https://my.acelynknavigator.com/Desktop/Invoices/?t=EntrySummary&id={reference_number}",
            "User-Agent": "Mozilla/5.0 (X11; Linux aarch64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36 CrKey/1.54.250320",
            "Cookie": cookie,
            "x-requested-with": "XMLHttpRequest"
        }

        response = requests.post(url, headers=headers, json=payload)

        return response.status_code, response.text

    def check_cookie_and_extract(entry_number, data):
        cookie = data.get("cookie")
        payload_str = data.get("payload")

        if not cookie or not cookie.strip():
            print(f"{entry_number} 没有有效的 cookie，跳过")
            return None
        if not payload_str or not payload_str.strip():
            print(f"{entry_number} payload 为空，跳过")
            return None

        try:
            payload = json.loads(payload_str)
        except Exception as e:
            print(f"{entry_number} payload 解析失败: {e}，跳过")
            return None

        importer_id = payload.get("importerId")
        reference_number = payload.get("referenceNumber")

        if not encoded_data or not encoded_data.strip():
            print(f"{entry_number} 没有有效的 encodedData，跳过")
            return None
        if not importer_id:
            print(f"{entry_number} 没有有效的 importer_id，跳过")
            return None
        if not reference_number or not str(reference_number).strip():
            print(f"{entry_number} 没有有效的 reference_number，跳过")
            return None

        return {
            "cookie": cookie,
            "importer_id": importer_id,
            "reference_number": reference_number,
        }

    all_data, txt_file_path = get_code(account, password)
    print(all_data)
    for entry_number, data in all_data.items():
        encoded_data = extract_encoded_data(entry_number, data)

        # 如果是 None 或者空字符串，跳过
        if not encoded_data or not encoded_data.strip():
            print(f"{entry_number} 没有有效的 encoded_data，跳过")
            update_output_text(output_text, f"\nLarry服务器无法成功上传此entry{entry_number}")
            continue

        decode_and_save(encoded_data, txt_file_path)
        main_update(txt_file_path)
        info = check_cookie_and_extract(entry_number, data)
        if info is None:
            update_output_text(output_text, f"\n{entry_number}上传失败")
            continue  # 任何一个信息缺失，跳过

        cookie = info['cookie']
        importer_id = info['importer_id']
        reference_number = info['reference_number']
        encoded_data = encode_json_file(txt_file_path)

        status, text = upload_encoded_data(encoded_data, importer_id, reference_number, cookie)
        if status == 200:
            update_output_text(output_text, f"\n{entry_number} 处理完成\n")
        else:
            update_output_text(output_text, f"\n{entry_number} 处理失败: {status}\n")

        print("状态码:", status)

        print(f"{entry_number} 处理完成\n")
    update_output_text(output_text, f"------------全部处理完成-----------------------------------")


def query_program(account, password, output_text):
    expiration_date = expiration_date1
    now = datetime.now()
    func_name = inspect.currentframe().f_code.co_name  # 自动获取当前函数名

    if expiration_date and now > expiration_date:
        if not is_user_allowed(func_name, account):
            update_output_text(output_text, "程序已过期，请联系Larry获取更新版本。\n\n")
            exit()

    # 获取用户主目录
    user_home = os.path.expanduser("~")

    # 检测可能的桌面路径
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    # 查找存在的桌面路径
    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "customextract.xlsx")
        if os.path.exists(file_path):
            update_output_text(output_text, f"找到文件：{file_path}\n\n")
        else:
            # 创建空的 Excel 文件
            wb = Workbook()
            wb.save(file_path)
            update_output_text(output_text, f"未找到文件，已创建新文件：{file_path}\n\n")
            sys.exit()  # 程序立即停止
    else:
        update_output_text(output_text, "未找到有效的桌面路径\n\n")
        sys.exit()  # 程序立即停止
    if desktop_path:
        output_path = os.path.join(desktop_path, "customoutput.xlsx")
        if os.path.exists(output_path):
            update_output_text(output_text, f"找到文件：{output_path}\n\n")
        else:
            # 创建空的 Excel 文件
            wb = Workbook()
            wb.save(output_path)
            update_output_text(output_text, f"未找到文件，已创建新文件：{update_output_text}\n\n")
            sys.exit()  # 程序立即停止
    else:
        update_output_text(output_text, "未找到有效的桌面路径\n\n")
        sys.exit()  # 程序立即停止
    token = "eyJhbGciOiJIUzI1NiIsInR5cCI6ImFjY2VzcyJ9.eyJpYXQiOjE3NDQxNTU2MzEsImV4cCI6MTc3NTY5MTYzMSwiYXVkIjoiaHR0cHM6Ly95b3VyZG9tYWluLmNvbSIsImlzcyI6ImZlYXRoZXJzIiwic3ViIjoiNjc2MzA0NWJmYjUzZDM1NDc0ZTExZjQ2IiwianRpIjoiZDhlMmU3OWEtMWFjNC00YmNjLWFmNmItYTVkMTljZGFjODdiIn0.q5_Cp_wURZEz4fV6P1mySAbbj0PYC1acS3Fd4m7G3Dk"

    # 读取 Excel 文件
    df = pd.read_excel(file_path, header=None, dtype=str)  # 如果没有列名，使用 header=None

    # 通过 iloc 访问第一列（假设是 A 列）
    mawb_list = df.iloc[0:, 0].tolist()
    # 过滤掉 'na' 和 NaN 值
    update_output_text(output_text, f"所有即将提取的master: {mawb_list}\n\n\n")

    def createquery(token, mawb):
        url = "https://api.customscity.com/api/manifest-query"
        headers = {
            "accept": "application/json",
            "Authorization": "Bearer " + token,
            "Content-Type": "application/json"
        }
        data = {
            "type": "AWBNUMBER",
            "masterBOLNumber": mawb,
            "houseBOLNumber": "null",
            "limitOutputOption": "",
            "requestRelatedBOL": False,
            "requestBOLAndEntryInformation": False
        }
        response = requests.post(url, headers=headers, json=data, timeout=10)
        if response.status_code != 200:
            print("Response:", response.status_code, response.text)

    for mawb in mawb_list:
        createquery(token, mawb)

    def delete_first_row(output_path):
        try:
            # 打开 Excel 文件
            wb = openpyxl.load_workbook(output_path)
            sheet = wb.active

            # 删除第一行
            sheet.delete_rows(1)

            # 保存修改后的 Excel 文件
            wb.save(output_path)
        except Exception as e:
            print(f"删除第一行时发生错误: {e}")

    # 示例调用：删除指定路径文件的第一行
    delete_first_row(output_path)

    def clear_excel_file(output_path):
        try:
            # 打开 Excel 文件
            wb = openpyxl.load_workbook(output_path)
            sheet = wb.active

            # 清空所有数据
            for row in sheet.iter_rows(min_row=1, max_row=sheet.max_row):
                for cell in row:
                    cell.value = None

            # 删除空行
            # 通过判断每行是否有有效数据来删除空行
            for row in range(sheet.max_row, 1, -1):
                if all(cell.value is None for cell in sheet[row]):
                    sheet.delete_rows(row)

            # 保存清空后的 Excel 文件
            wb.save(output_path)
        except Exception as e:
            print(f"无法清空: {e}")

    def extract_and_update_excel(response_data, output_path, awbcode):
        try:
            first_record = response_data['data']['response'][0]

            if 'masterPartIndicator' in first_record and first_record['masterPartIndicator'] != '':
                print(f"{awbcode} 是分批！！")

            wb = openpyxl.load_workbook(output_path)
            sheet = wb.active

            if sheet.max_row == 1:
                sheet.append(
                    ['Master BOL Number', 'Carrier Code', 'Vessel', 'Voyage/Flight No', 'Arrival Date', 'FIRMS',
                     '1D Count', '1H Count', '1A Count', '2H Count', '1I Count', '2I Count', '1C Count', '1B Count',
                     'House', 'port', 'qty',"1R Count","1X Count"])

            # 提取字段，每个字段都 try-except 防止报错
            def safe_extract(label, func):
                try:
                    return func()
                except Exception as e:
                    print(f"❌ 提取字段 [{label}] 时出错: {e}")
                    return "N/A"

            master_bol_number = safe_extract("master_bol_number", lambda: first_record.get('awbNumber', 'N/A'))
            carrier_code = safe_extract("carrier_code",
                                        lambda: first_record.get('houses', [{}])[0].get('importingCarrierCode', 'N/A'))
            vessel = safe_extract("vessel",
                                  lambda: first_record.get('importingVesselCodeOrImpConveyanceName', 'N/A').split()[0])
            voyage_flight_no = safe_extract("voyage_flight_no",
                                            lambda: first_record.get('houses', [{}])[0].get('flightNumber', 'N/A'))
            arrival_date = safe_extract("arrival_date",
                                        lambda: response_data.get('data', {}).get('response', [{}])[0].get(
                                            'wr1DateOfArrival', 'N/A'))
            firms = safe_extract("firms", lambda: first_record.get('firmsCode', 'N/A'))
            hawb_number = safe_extract("hawb_number",
                                       lambda: first_record.get('houses', [{}])[0].get('hawbNumber', 'N/A'))
            actual_port_of_unlading = safe_extract("actual_port_of_unlading",
                                                   lambda: first_record.get('manifestedPortOfUnlading', 'N/A'))
            qty = safe_extract("qty", lambda: first_record.get('houses', [{}])[0].get('manifestQty', 'N/A'))

            # 统计 dispositionCode
            disposition_codes = ['1D', '1H', '1A', '2H', '1I', '2I', '1B',"1R","1X"]
            all_disp_codes = []

            for house in first_record.get('houses', []):
                awb_number = house.get('awbNumber', 'N/A')
                disposition_msg = house.get('dispositionMsg', [])
                for disp in disposition_msg:
                    try:
                        code = disp['dispositionCode']
                        if code in ['1H', '1A', '2H', '1I', '2I', '1B']:
                            update_output_text(output_text, f"{awb_number} {house.get('hawbNumber', 'N/A')} {code}\n")
                        all_disp_codes.append(code)
                    except Exception as e:
                        print(f"⚠️ dispositionMsg 错误: {e}")

            code_counts = Counter(all_disp_codes)
            count_1d = code_counts.get('1D', 0)
            count_1h = code_counts.get('1H', 0)
            count_1a = code_counts.get('1A', 0)
            count_2h = code_counts.get('2H', 0)
            count_1i = code_counts.get('1I', 0)
            count_2i = code_counts.get('2I', 0)
            count_1c = code_counts.get('1C', 0)
            count_1B = code_counts.get('1B', 0)
            count_1r = code_counts.get('1R', 0)
            count_1x = code_counts.get('1X', 0)


            qty = count_1h + count_2h + count_1a - count_1i - count_2i - count_1B
            # 写入 Excel
            sheet.append([
                master_bol_number, carrier_code, vessel, voyage_flight_no, arrival_date, firms,
                count_1d, count_1h, count_1a, count_2h, count_1i, count_2i, count_1c,
                count_1B, hawb_number, actual_port_of_unlading, qty,count_1r,count_1x
            ])

            red_fill = PatternFill(start_color="FF9999", end_color="FF9999", fill_type="solid")
            green_fill = PatternFill(start_color="99FF99", end_color="99FF99", fill_type="solid")

            row_idx = sheet.max_row  # 获取刚写入的行号
            qty_cell = sheet.cell(row=row_idx, column=17)  # QTY 列在第17列

            if qty != 0:
                qty_cell.fill = red_fill
            else:
                qty_cell.fill = green_fill
            wb.save(output_path)

        except Exception as e:
            awb = first_record.get('awbNumber', '未知AWB') if 'first_record' in locals() else awbcode
            print(f"❌ 提取信息 [{awb}] 时总错误: {e}")

    def checkstatus(token, awbcode, output_path):
        url = "https://api.customscity.com/api/ManifestQueryLatestResponse"
        params = {"type": "AWBNUMBER", "masterBOLNumber": awbcode}
        headers = {"accept": "application/json", "Authorization": "Bearer " + token}
        max_retries = 10
        for attempt in range(max_retries):
            try:
                response = requests.get(url, headers=headers, params=params)

                if response.status_code == 200:
                    response_data = response.json()
                    if "message" in response_data and response_data["message"] == "No response yet":
                        time.sleep(5)
                        continue
                    extract_and_update_excel(response_data, output_path, awbcode)
                    print(response_data)
                    return response_data
                else:
                    time.sleep(5)
            except requests.exceptions.RequestException as e:
                time.sleep(5)
        print(f"Max retries reached for AWB {awbcode}. Unable to get a valid response.")
        return None

    # 示例调用：请确保 `mawb_list` 和 `output_path` 已定义
    clear_excel_file(output_path)
    for mawb in mawb_list:
        checkstatus(token, mawb, output_path)
    update_output_text(output_text, "操作已完成请检查master数量\n\n")


def QP_program(account, password, output_text):
    expiration_date = expiration_date1
    now = datetime.now()
    func_name = inspect.currentframe().f_code.co_name  # 自动获取当前函数名

    if expiration_date and now > expiration_date:
        if not is_user_allowed(func_name, account):
            update_output_text(output_text, "程序已过期，请联系Larry获取更新版本。\n\n")
            exit()

    # 获取用户主目录
    user_home = os.path.expanduser("~")

    # 检测可能的桌面路径
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    # 查找存在的桌面路径
    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "extract.xlsx")
        if os.path.exists(file_path):
            update_output_text(output_text, f"找到文件：{file_path}\n\n")
        else:
            # 创建空的 Excel 文件
            wb = Workbook()
            wb.save(file_path)
            update_output_text(output_text, f"未找到文件，已创建新文件：{file_path}\n\n")
            sys.exit()  # 程序立即停止
    else:
        update_output_text(output_text, "未找到有效的桌面路径\n\n")
        sys.exit()  # 程序立即停止

    # 读取 Excel 文件
    df = pd.read_excel(file_path, header=None, dtype=str)  # 如果没有列名，使用 header=None

    # 通过 iloc 访问第一列（假设是 A 列）
    a_column = df.iloc[:, 0]  # 选择第一列

    # 过滤掉 'na' 和 NaN 值
    filtered_list = a_column[a_column.notna() & (a_column != 'na')].tolist()
    update_output_text(output_text, f"所有要处理的inbond: {filtered_list}\n\n\n")

    try:
        # 配置 ChromeOptions
        options = webdriver.ChromeOptions()
        chrome_binary = r"C:\Program Files\Google\Chrome\Application\chrome.exe"
        options.binary_location = chrome_binary
        options.add_argument("--no-sandbox")
        options.add_argument("--disable-dev-shm-usage")

        # 检查 Chrome 可执行文件是否存在
        if os.path.exists(chrome_binary):
            update_output_text(output_text, f"Chrome 可执行文件存在: {chrome_binary}\n")
        else:
            update_output_text(output_text, f"Chrome 可执行文件不存在: {chrome_binary}\n")
            raise FileNotFoundError(f"Chrome 可执行文件未找到: {chrome_binary}")

        # 获取 ChromeDriver 路径和版本
        try:
            driver_path = ChromeDriverManager().install()
            update_output_text(output_text, f"ChromeDriver 路径: {driver_path}\n")
            # 检查 ChromeDriver 版本
            driver_version = subprocess.check_output([driver_path, "--version"]).decode().strip()
            update_output_text(output_text, f"ChromeDriver 版本: {driver_version}\n")
        except Exception as e:
            update_output_text(output_text, f"获取 ChromeDriver 路径或版本失败: {str(e)}\n")
            raise

        # 检查系统 PATH
        system_path = os.environ.get("PATH", "")
        update_output_text(output_text, f"系统 PATH: {system_path}\n")

        # 初始化 Chrome 浏览器
        update_output_text(output_text, "开始初始化 ChromeDriver...\n")
        driver = webdriver.Chrome(service=Service(driver_path), options=options)
        update_output_text(output_text, "ChromeDriver 初始化成功\n")

    except webdriver.WebDriverException as wde:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (WebDriverException): {str(wde)}\n")
        update_output_text(output_text, f"堆栈跟踪: {traceback.format_exc()}\n")
        raise
    except FileNotFoundError as fnfe:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (FileNotFoundError): {str(fnfe)}\n")
        raise
    except Exception as e:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (未知错误): {str(e)}\n")
        update_output_text(output_text, f"堆栈跟踪: {traceback.format_exc()}\n")
        raise
    url = "https://www.netchb.com/app/home.do"
    driver.get(url)

    WebDriverWait(driver, 20).until(
        EC.presence_of_element_located((By.XPATH, '//*[@id="lName"]'))
    ).send_keys(account)

    # 等待 Password 输入框出现并输入密码
    WebDriverWait(driver, 20).until(
        EC.presence_of_element_located((By.XPATH, '//*[@id="pass"]'))
    ).send_keys(password)

    xpath = '//*[@id="loginForm"]/div[2]/input'
    login_button = driver.find_element(By.XPATH, xpath)
    login_button.click()
    target_url = f"https://www.netchb.com/app/inbond/inbondMenu.do?itNo={'054294590'}"
    # 打开页面
    driver.get(target_url)
    # 遍历 filtered_list 中的每个项目
    for item in filtered_list:
        if windowname != "task":
            print("窗口已关闭，程序终止。")  # 调试打印
            update_output_text(output_text, "窗口已关闭，程序终止。\n\n\n")
            sys.exit()  # 窗口已关闭，退出程序
        target_url = f"https://www.netchb.com/app/inbond/inbondMenu.do?itNo={item}"
        # 打开页面
        driver.get(target_url)

        current_title = driver.title
        update_output_text(output_text, f"正在处理{item}\n")

        try:
            # 查找特定的元素，增加最长等待时间
            element_xpath = '/html/body/table/tbody/tr[2]/td[1]/table[4]/tbody/tr[1]/td[2]/a'
            # 等待最多 50 秒，直到元素可点击
            element = WebDriverWait(driver, 50).until(
                EC.element_to_be_clickable((By.XPATH, element_xpath))
            )

            # 如果元素存在并且可点击，点击它
            element.click()

        except Exception as e:
            # 如果元素未找到或不可点击，打印消息
            update_output_text(output_text, f"在处理 {item}时出现问题！错误: {e}\n")

    # 等待用户输入后关闭浏览器
    input("按 Enter 键关闭浏览器...")
    driver.quit()


import os
import msoffcrypto
import pandas as pd
from datetime import datetime

def line_extract(account, password, output_text):
    expiration_date = expiration_date1
    now = datetime.now()
    func_name = inspect.currentframe().f_code.co_name  # 自动获取当前函数名

    if expiration_date and now > expiration_date:
        if not is_user_allowed(func_name, account):
            update_output_text(output_text, "程序已过期，请联系Larry获取更新版本。\n\n")
            exit()

    # Step 2 — 找桌面路径
    user_home = os.path.expanduser("~")
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]
    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)
    if not desktop_path:
        update_output_text(output_text, "❌ 未找到有效的桌面路径\n\n")
        sys.exit()

    folder_path = os.path.join(desktop_path, "Line extract")
    if not os.path.exists(folder_path):
        os.makedirs(folder_path)
        update_output_text(output_text, f"⚠️ 未找到文件夹，已创建新文件夹：{folder_path}\n\n")
        sys.exit()

    # Step 3 — 找文件
    excel_files = [f for f in os.listdir(folder_path) if f.lower().endswith(('.xls', '.xlsx')) and not f.startswith('~$')]
    packing_list_file = None
    invoice_file = None
    for file in excel_files:
        if "packing list" in file.lower():
            packing_list_file = file
        elif "invoice" in file.lower():
            invoice_file = file

    if not packing_list_file or not invoice_file:
        update_output_text(output_text, "❌ 缺少必要文件，程序退出\n")
        exit()

    packing_list_passwords = ["4!vCwY65@8", "bC_72=ukwG", "Gcp76!Ch3Y", "A&$*yv#3m5"]

    def try_decrypt(file_path, passwords):
        decrypted_file_path = file_path + ".decrypted.xlsx"
        success = False
        for pwd in passwords:
            try:
                with open(file_path, "rb") as f:
                    doc = msoffcrypto.OfficeFile(f)
                    doc.load_key(pwd)
                    with open(decrypted_file_path, "wb") as decrypted_file:
                        doc.decrypt(decrypted_file)
                update_output_text(output_text, f"✅ 使用密码 '{pwd}' 解密成功：{os.path.basename(file_path)}\n")
                success = True
                break
            except Exception as e:
                update_output_text(output_text, f"❌ 使用密码 '{pwd}' 失败: {e}\n")
        return decrypted_file_path if success else None

    # 解密 packing list
    packing_list_path = os.path.join(folder_path, packing_list_file)
    decrypted_packing_list = try_decrypt(packing_list_path, packing_list_passwords)
    if not decrypted_packing_list:
        update_output_text(output_text, "❌ Packing list 无法解密\n")
        exit()

    df_packing = pd.read_excel(decrypted_packing_list, header=8)  # 第9行header
    aa_column = df_packing.iloc[:, 26].astype(str)  # AA列
    ab_column = df_packing.iloc[:, 27].astype(str)  # AB列

    # 读取 df (BBCreview.xlsx 第一列)
    df_file = os.path.join(desktop_path, "BBCreview.xlsx")
    df = pd.read_excel(df_file, header=None, dtype=str)
    
    first_column_list = df.iloc[:, 0].dropna().tolist()
    
    # 用于记录补了0的值
    padded_values = []
    
    # 处理每个值，不足12位前面补0
    for i in range(len(first_column_list)):
        original = first_column_list[i]
        if len(original) < 12:
            first_column_list[i] = original.zfill(12)
            padded_values.append(first_column_list[i])
    
    # 输出处理后的列表
    update_output_text(output_text, first_column_list)
    
    # 如果有补0的，输出提示
    if padded_values:
        update_output_text(output_text, f"这些补了0: {padded_values}")

















    result_dict = {}
    for val in first_column_list:
        matched_indices = aa_column[aa_column.str.contains(str(val), na=False)].index.tolist()
        ab_values = [ab_column.iloc[i] for i in matched_indices]
        result_dict[val] = ab_values

    invoice_path = os.path.join(folder_path, invoice_file)
    df_invoice = pd.read_excel(invoice_path, header=0)
    x_column = df_invoice.iloc[:, 23].astype(str)
    y_column = df_invoice.iloc[:, 24].astype(str)
    bl_column = df_invoice.iloc[:, 63]

    from openpyxl import load_workbook
    import re

    # 加载 Excel 文件
    wb = load_workbook(df_file)  # df_file 是路径
    ws = wb.active  # 默认第一个 sheet

    row_idx = 1  # 从第一行开始写
    from openpyxl import load_workbook
    import re

    wb = load_workbook(df_file)  # df_file 是路径
    ws = wb.active

    row_idx = 1  # 从第一行开始写
    for key, ab_vals in result_dict.items():
        for ab_val in ab_vals:
            entry_match = re.search(r"_entry_(\d+)", ab_val)
            line_match = re.search(r"_line_(\d+)", ab_val)

            if entry_match and line_match:
                entry_num = entry_match.group(1)
                line_num = line_match.group(1)

                update_output_text(output_text, f"匹配 entry:{entry_num}, line:{line_num}\n")

                matches = df_invoice[
                    (df_invoice.iloc[:, 23].astype(str).str.strip() == entry_num) &
                    (df_invoice.iloc[:, 24].astype(str).str.strip() == line_num)
                    ]

                found_value = "N/A"
                if not matches.empty:
                    found_value = matches.iloc[0, 63]  # BL 列
                    update_output_text(output_text, f"{key} {found_value}\n")
                else:
                    update_output_text(output_text,
                                       f"⚠️ 没有找到对应 entry:{entry_num} line:{line_num} 的 Invoice 数据\n")

                # 写入 Excel
                ws.cell(row=row_idx, column=1, value=key)  # 第一列写 key
                ws.cell(row=row_idx, column=3, value=found_value)  # 第三列写 found_value
                row_idx += 1

    wb.save(df_file)

    # 删除多余解密文件
    for file in os.listdir(folder_path):
        if file.endswith(".decrypted.xlsx"):
            os.remove(os.path.join(folder_path, file))
            update_output_text(output_text, f"🗑 删除临时解密文件: {file}\n")

    update_output_text(output_text, "✅ 完成所有步骤\n")

def Nikki_template(account, password, output_text):
    expiration_date = expiration_date1
    now = datetime.now()
    func_name = inspect.currentframe().f_code.co_name  # 自动获取当前函数名

    if expiration_date and now > expiration_date:
        if not is_user_allowed(func_name, account):
            update_output_text(output_text, "程序已过期，请联系Larry获取更新版本。\n\n")
            exit()

    # Step 2 — 找桌面路径
    user_home = os.path.expanduser("~")
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]
    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)
    if not desktop_path:
        update_output_text(output_text, "❌ 未找到有效的桌面路径\n\n")
        sys.exit()

    folder_path = os.path.join(desktop_path, "Nikki")
    if not os.path.exists(folder_path):
        os.makedirs(folder_path)
        update_output_text(output_text, f"⚠️ 未找到文件夹，已创建新文件夹：{folder_path}\n\n")
        sys.exit()
    # 获取Excel文件路径（假设文件夹里只有一个Excel文件）
    try:
        folder_path = os.path.join(desktop_path, "Nikki")
        if not os.path.exists(folder_path):
            os.makedirs(folder_path)
            update_output_text(output_text, f"⚠️ 未找到文件夹，已创建新文件夹：{folder_path}\n\n")
            return

        files = [f for f in os.listdir(folder_path) if f.endswith('.xlsx')]

        if not files:
            update_output_text(output_text, "❌ 文件夹中没有找到 Excel 文件！\n\n")
            return

        if len(files) > 1:
            update_output_text(output_text, "❌ 文件夹中有多个 Excel 文件，请只保留一个！\n\n")
            return

        file_name = os.path.splitext(files[0])[0]  # 获取唯一文件名（无后缀）
        file_path = os.path.join(folder_path, files[0])

    except Exception as e:
        update_output_text(output_text, f"❌ 读取文件夹出错：{e}\n\n")
        return

        file_name = os.path.splitext(files[0])[0]
        file_path = os.path.join(folder_path, files[0])
    except Exception as e:
        update_output_text(output_text, f"❌ 检查或创建文件夹时出错：{e}\n\n")
        return

    # ===== Step 4. 读取 Excel =====
    try:
        df = pd.read_excel(file_path, header=None)
        print(df.head(15))
    except Exception as e:
        update_output_text(output_text, f"❌ 读取 Excel 文件失败：{e}\n\n")
        return

    try:
        header_row = df.iloc[8].tolist()
        df = df.iloc[10:].reset_index(drop=True)
        df.columns = header_row
        print(header_row)
    except Exception as e:
        update_output_text(output_text, f"❌ 处理表头时出错：{e}\n\n")
        return

    # ===== Step 5. 找到有效数据范围 =====
    try:
        k_col = df.iloc[:, 10]
        first_blank_index = k_col[k_col.isna() | (k_col.astype(str).str.strip() == '')].index
        if len(first_blank_index) > 0:
            stop_index = first_blank_index[0]
            df = df.loc[:stop_index - 1].reset_index(drop=True)
    except Exception as e:
        update_output_text(output_text, f"❌ 查找空行时出错：{e}\n\n")
        return

    # ===== Step 6. 查找列函数 =====
    def find_col(keyword):
        try:
            tenth_row = pd.Series(header_row)  # 转换为 Series
            match = tenth_row[tenth_row.astype(str).str.contains(keyword, case=False, na=False)]
            return match.index[0] if not match.empty else None
        except Exception as e:
            update_output_text(output_text, f"❌ 查找列时出错（关键字 {keyword}）：{e}\n\n")
            return None

    hts_col = find_col("HS")
    qty_col = find_col("Quantity")
    usd_col = find_col("Amount")
    kg_col = find_col("N.W")
    net_col = find_col("G.W")
    # ===== Step 7. 生成新表 =====
    try:
        new_df = pd.DataFrame(index=df.index)
        new_df[1] = ""
        new_df[2] = ""
        new_df[3] = "CN"
        new_df[4] = "CN"

        new_df[5] = df.iloc[:, hts_col].apply(
            lambda x: ''.join(re.findall(r'\d+', str(x)))) if hts_col is not None else ""
        new_df[6] = df.iloc[:, qty_col] if qty_col is not None else ""
        new_df[7] = "PCS"
        new_df[8] = df.iloc[:, usd_col].astype(float) / df.iloc[:, qty_col].astype(
            float) if usd_col is not None and qty_col is not None else ""

        def round_value(value):
            try:
                return round(float(value), 0)
            except Exception:
                return value

        new_df[9] = df.iloc[:, usd_col].apply(
            lambda x: round_value(x) if pd.notna(x) else "") if usd_col is not None else ""
        new_df[10] = df.iloc[:, kg_col] if kg_col is not None else ""
        new_df[11] = df.iloc[:, net_col] if net_col is not None else ""


    except Exception as e:
        update_output_text(output_text, f"❌ 生成新表时出错：{e}\n\n")
        return

    # ===== Step 8. 拆分并导出 =====
    try:
        header_row = [
            "Invoice_No", "Part", "Commercial_Description", "Country_of_Origin", "Country_of_Export",
            "Tariff_Number", "Quantity", "Quantity_UOM", "Unit_Price", "Total_Line_Value", "Net_Weight_KG",
            "Gross_Weight_KG", "Manufacturer_Name", "Manufacturer_Address_1", "Manufacturer_Address_2",
            "Manufacturer_City", "Manufacturer_State", "Manufacturer_Zip", "Manufacturer_Country", "MID_Code",
            "Buyer_Name", "Buyer_Address_1", "Buyer_Address_2", "Buyer_City", "Buyer_State", "Buyer_Zip",
            "Buyer_Country", "Buyer_ID_Number", "Consignee_Name", "Consignee_Address_1", "Consignee_Address_2",
            "Consignee_City", "Consignee_State", "Consignee_Zip", "Consignee_Country", "Consignee_ID_Number",
            "SICountry", "SP1", "SP2", "Zone_Status", "Privileged_Filing_Date", "Line_Piece_Count",
            "ADD_Case_Number", "CVD_Case_Number", "AD_Non_Reimbursement_Statement", "AD-CVD_Certification_Designation"
        ]

        split_size = 998
        num_files = (len(new_df) // split_size) + (1 if len(new_df) % split_size != 0 else 0)
        letters = list(string.ascii_uppercase)

        def safe_write_value(value):
            if isinstance(value, (float, int)) and (np.isnan(value) or np.isinf(value)):
                return ""
            return value

        for i in range(num_files):
            start_row = i * split_size
            end_row = start_row + split_size
            split_df = new_df.iloc[start_row:end_row].copy()

            split_df.insert(0, "File Name", file_name + "-" + letters[i])
            output_file = os.path.join(folder_path, f"{file_name}-{letters[i]}.xlsx")

            wb = Workbook()
            ws = wb.active
            ws.title = "Sheet1"

            # 写入表头
            for col_num, value in enumerate(header_row, start=1):
                ws.cell(row=1, column=col_num, value=value)

            # 写入数据
            for row_num, row in enumerate(split_df.values, start=2):
                for col_num, value in enumerate(row, start=1):
                    ws.cell(row=row_num, column=col_num, value=safe_write_value(value))

            wb.save(output_file)
    except Exception as e:
        update_output_text(output_text, f"❌ 导出文件时出错：{e}\n\n")
        return

    update_output_text(output_text, f"✅ 拆分完成，共生成 {num_files} 个 Excel 文件。\n\n")

def wechat(account, password, output_text):
    from seleniumwire import webdriver
    chrome_options = webdriver.ChromeOptions()
    chrome_options.add_argument("--start-maximized")  # 启动时最大化
    chrome_options.add_argument("--disable-gpu")  # 解决某些系统的图形渲染问题
    chrome_options.add_argument("--no-sandbox")  # 非root用户需要此参数
    chrome_options.add_argument("--disable-dev-shm-usage")  # 避免某些共享内存问题
    chrome_options.add_argument("--always-on-top")  # 窗口置顶 (实验性参数)
    chrome_options.add_argument("--force-device-scale-factor=0.5")  # 设置缩放比例为50%

    # 启动 Chrome 浏览器并加载已保存的用户数据
    driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=chrome_options)
    driver.set_window_size(1920, 1080)

    # 通过 JavaScript 强制设置缩放比例
    driver.get("https://www.google.com")
    driver.execute_script("document.body.style.zoom='50%'")
    url = "https://raw.githubusercontent.com/Shirasagi-no-Mai/weixinQR-code/refs/heads/main/91c3d7487460721a695e43613d8203d.jpg"
    driver.get(url)
    driver.maximize_window()  # 最大化窗口

    all_tabs = driver.window_handles
    all_tabs = driver.window_handles 

def reverse_line_extract(account, password, output_text):
    expiration_date = expiration_date1
    now = datetime.now()
    func_name = inspect.currentframe().f_code.co_name  # 自动获取当前函数名

    if expiration_date and now > expiration_date:
        if not is_user_allowed(func_name, account):
            update_output_text(output_text, "程序已过期，请联系Larry获取更新版本。\n\n")
            exit()

    # Step 2 — 找桌面路径
    user_home = os.path.expanduser("~")
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]
    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)
    if not desktop_path:
        update_output_text(output_text, "❌ 未找到有效的桌面路径\n\n")
        sys.exit()

    folder_path = os.path.join(desktop_path, "Line extract")
    if not os.path.exists(folder_path):
        os.makedirs(folder_path)
        update_output_text(output_text, f"⚠️ 未找到文件夹，已创建新文件夹：{folder_path}\n\n")
        sys.exit()

    # Step 3 — 找文件
    excel_files = [f for f in os.listdir(folder_path) if f.lower().endswith(('.xls', '.xlsx')) and not f.startswith('~$')]
    packing_list_file = None
    invoice_file = None
    for file in excel_files:
        if "packing list" in file.lower():
            packing_list_file = file
        elif "invoice" in file.lower():
            invoice_file = file

    if not packing_list_file or not invoice_file:
        update_output_text(output_text, "❌ 缺少必要文件，程序退出\n")
        exit()

    packing_list_passwords = ["4!vCwY65@8", "bC_72=ukwG", "Gcp76!Ch3Y", "A&$*yv#3m5"]

    def try_decrypt(file_path, passwords):
        decrypted_file_path = file_path + ".decrypted.xlsx"
        success = False
        for pwd in passwords:
            try:
                with open(file_path, "rb") as f:
                    doc = msoffcrypto.OfficeFile(f)
                    doc.load_key(pwd)
                    with open(decrypted_file_path, "wb") as decrypted_file:
                        doc.decrypt(decrypted_file)
                update_output_text(output_text, f"✅ 使用密码 '{pwd}' 解密成功：{os.path.basename(file_path)}\n")
                success = True
                break
            except Exception as e:
                update_output_text(output_text, f"❌ 使用密码 '{pwd}' 失败: {e}\n")
        return decrypted_file_path if success else None

    # 解密 packing list
    packing_list_path = os.path.join(folder_path, packing_list_file)
    decrypted_packing_list = try_decrypt(packing_list_path, packing_list_passwords)
    if not decrypted_packing_list:
        update_output_text(output_text, "❌ Packing list 无法解密\n")
        exit()

    df_packing = pd.read_excel(decrypted_packing_list, header=8, dtype=str)  # 第9行header
    aa_column = df_packing.iloc[:, 26].astype(str)  # AA列
    ab_column = df_packing.iloc[:, 27].astype(str)  # AB列

    # 读取 df (BBCreview.xlsx 第一列和第三列)
    df_file = os.path.join(desktop_path, "BBCreview.xlsx")
    df = pd.read_excel(df_file, header=None, dtype=str)

    invoice_path = os.path.join(folder_path, invoice_file)
    df_invoice = pd.read_excel(invoice_path, header=0, dtype=str)

    from openpyxl import load_workbook
    import re

    # 加载 Excel 文件
    wb = load_workbook(df_file)
    ws = wb.active

    for row_idx in range(1, ws.max_row + 1):
        entry_val = str(ws.cell(row=row_idx, column=1).value).strip()
        line_val = str(ws.cell(row=row_idx, column=3).value).strip()

        if not entry_val or not line_val:
            continue

        # 找 invoice 中对应行 (BJ=entry_val, BL=line_val)
        matches = df_invoice[
            (df_invoice.iloc[:, 61].astype(str).str.strip() == entry_val) &  # BJ列
            (df_invoice.iloc[:, 63].astype(str).str.strip() == line_val)     # BL列
        ]

        if matches.empty:
            update_output_text(output_text, f"⚠️ 没有找到对应 entry:{entry_val} line:{line_val} 的 Invoice 数据\n")
            continue

        X = matches.iloc[0, 23]  # X列
        Y = matches.iloc[0, 24]  # Y列
        target_suffix = f"entry_{X}_line_{Y}"

        # 在 packing list 找后缀匹配
        aa_match = None
        for i, ab_val in enumerate(ab_column):
            if str(ab_val).strip().endswith(target_suffix):
                aa_val = str(aa_column.iloc[i])
                aa_match = aa_val[-12:] if len(aa_val) >= 12 else aa_val
                break

        # 写入第五列
        ws.cell(row=row_idx, column=5, value=aa_match if aa_match else "N/A")
        update_output_text(output_text, f"匹配 entry:{entry_val}, line:{line_val} -> {aa_match if aa_match else 'N/A'}\n")

    wb.save(df_file)

    # 删除多余解密文件
    for file in os.listdir(folder_path):
        if file.endswith(".decrypted.xlsx"):
            os.remove(os.path.join(folder_path, file))
            update_output_text(output_text, f"🗑 删除临时解密文件: {file}\n")

    update_output_text(output_text, "✅ 完成反向提取步骤\n")



def document_program(account, password, output_text):
    expiration_date = expiration_date1
    now = datetime.now()
    func_name = inspect.currentframe().f_code.co_name  # 自动获取当前函数名

    if expiration_date and now > expiration_date:
        if not is_user_allowed(func_name, account):
            update_output_text(output_text, "程序已过期，请联系Larry获取更新版本。\n\n")
            exit()

    user_home = os.path.expanduser("~")
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "BBCreview.xlsx")
        if os.path.exists(file_path):
            pass
        else:
            wb = Workbook()
            wb.save(file_path)
            sys.exit()
    else:
        sys.exit()

    chrome_options = webdriver.ChromeOptions()
    chrome_options.add_argument("--start-maximized")  # 启动时最大化
    chrome_options.add_argument("--disable-gpu")  # 解决某些系统的图形渲染问题
    chrome_options.add_argument("--no-sandbox")  # 非root用户需要此参数
    chrome_options.add_argument("--disable-dev-shm-usage")  # 避免某些共享内存问题
    chrome_options.add_argument("--always-on-top")  # 窗口置顶 (实验性参数)
    chrome_options.add_argument("--force-device-scale-factor=0.5")  # 设置缩放比例为50%

    # 启动 Chrome 浏览器并加载已保存的用户数据
    driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=chrome_options)
    driver.set_window_size(1920, 1080)

    # 通过 JavaScript 强制设置缩放比例
    driver.get("https://www.google.com")
    driver.execute_script("document.body.style.zoom='50%'")
    url = "https://my.acelynknavigator.com/Account/Login.aspx?ReturnUrl=%2fDesktop%2fDefault.aspx"
    driver.get(url)
    driver.maximize_window()  # 最大化窗口

    all_tabs = driver.window_handles
    all_tabs = driver.window_handles

    # 遍历所有窗口，关闭不需要的 "data:" 标签页
    for tab in all_tabs:
        driver.switch_to.window(tab)
        if "data:" in driver.current_url:
            driver.close()  # 关闭 "data:" 标签页

    # 重新获取当前所有窗口句柄
    all_tabs = driver.window_handles

    # 如果有剩余窗口，切换到第一个
    if all_tabs:
        driver.switch_to.window(all_tabs[0])

    try:
        # 等待页面加载并检查是否包含 "sign"
        WebDriverWait(driver, 10).until(
            lambda d: "sign" in d.page_source.lower()  # 等待直到页面包含 "sign"
        )
        print("'sign' found in page source. Continuing...")
    except Exception as e:
        print("Timeout or error while waiting for 'sign':", e)
        driver.quit()
        exit()

    # 输入账号和密码
    username = account  # 替换为实际账号
    password = password  # 替换为实际密码

    # 定位到账号和密码输入框
    username_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_UserName"]')
    username_field.clear()  # 清除输入框中的任何内容
    username_field.send_keys(username)  # 输入用户名

    # 输入密码
    password_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_Password"]')
    password_field.clear()  # 清除输入框中的任何内容
    password_field.send_keys(password)  # 输入密码

    # 点击登录按钮
    login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")  # 替换为实际 ID
    login_button.click()
    print("Current page title is:", driver.title)
    WebDriverWait(driver, 10).until(EC.title_contains("Compliance"))  # 等待页面标题更新为登录后的内容

    try:
        # 定位到登录按钮并点击
        login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")
        login_button.click()

        # 等待检查是否有警告框弹出
        try:
            logout_button = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable((By.XPATH, "//*[@id='lbtLogOutAllSessions']"))
            )
            logout_button.click()
            print("Clicked the logout button in the alert.")

            # 等待页面刷新（可以根据 URL 变化或某个标志性元素来确认）
            WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.ID, "LoginMenu_LoginButton"))  # 确保登录按钮存在
            )
            time.sleep(2)
            username_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_UserName"]')
            username_field.clear()  # 清除输入框中的任何内容
            username_field.send_keys(username)  # 输入用户名

            # 输入密码
            password_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_Password"]')
            password_field.clear()  # 清除输入框中的任何内容
            password_field.send_keys(password)  # 输入密码
            # 重新定位登录按钮
            login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")
            login_button.click()
            print("Clicked the login button.")

        except TimeoutException:
            print("No alert appeared, proceeding with the login.")

        # 等待页面跳转并检查登录后页面标题
        WebDriverWait(driver, 10).until(
            EC.title_contains("Dashboard")  # 这里用登录后的页面标题的一个关键字
        )
        print("Login successful. Page title is:", driver.title)

    except (TimeoutException, NoSuchElementException) as e:
        print(f"Error occurred during login: {e}")
    outputdf = pd.DataFrame(columns=["entry_number", "status_img_src", "pga_img_src", "first_column_data"])
    driver.get("https://my.acelynknavigator.com/Desktop/Default.aspx")
    step_status = True

    def check_alert(driver):
        try:
            time.sleep(1)
            alert = driver.switch_to.alert
            alert_text = alert.text
            print("弹窗内容:", alert_text)

            if "cotton" not in alert_text.lower():
                alert.accept()
                print("已点击确认按钮")
            else:
                alert.dismiss()
                print("检测到 'cotton'，已点击取消按钮")

            time.sleep(1)
        except NoAlertPresentException:
            pass  # 没有弹窗，跳过

    def wait_for_block_to_disappear(driver, timeout=40, check_interval=1):
        end_time = time.time() + timeout
        while time.time() < end_time:
            try:
                # 查找遮罩层
                blocking_elements = driver.find_elements(By.CSS_SELECTOR, ".blockUI.blockOverlay")
                if not blocking_elements:
                    print("✅ 阻挡元素消失，继续操作")
                    return
                print("⏳ 检测到遮罩层，等待中...")
                time.sleep(check_interval)
            except UnexpectedAlertPresentException:
                try:
                    alert = driver.switch_to.alert
                    print("⚠️ 检测到 alert 弹窗：", alert.text)
                    alert.accept()
                    print("✅ 已点击确认关闭 alert")
                    time.sleep(1)
                except NoAlertPresentException:
                    print("❌ 想处理 alert，但找不到")
                continue
            except Exception as e:
                print(f"⚠️ 检测遮罩层时出现错误: {e}")
                time.sleep(check_interval)
                continue

    def open_entry(driver):

        try:
            driver.switch_to.default_content()
            print("✅ 已返回主页面")
        except Exception as e:
            print(f"❌ 返回主页面失败: {e}")
        try:

            # 点击图片（如果非绿标的情况下）
            img_xpath = "(//td[contains(@id, 'EntrySummary')]//ul[@class='nav2']//img)[1]"
            img_element = driver.find_element(By.XPATH, img_xpath)

            # 用WebElement传入move_to_element
            ActionChains(driver).move_to_element(img_element).perform()
            time.sleep(1)  # 适当等待悬停触发的效果

            check_alert(driver)
            # 等待edit按钮可点击并点击（循环10秒，每秒尝试）
            timeout = 10  # 最大等待时间10秒
            interval = 1  # 每隔1秒尝试一次
            start_time = time.time()

            while True:
                try:
                    edit_img = WebDriverWait(driver, interval).until(
                        EC.element_to_be_clickable(
                            (By.XPATH, "//a[contains(@class,'shipment-row')]/img[@src='/images/icons/edit_30x30.png']"))
                    )
                    edit_img.click()
                    print("点击成功")
                    break  # 点击成功跳出循环
                except (ElementClickInterceptedException, TimeoutException) as e:
                    elapsed = time.time() - start_time
                    if elapsed >= timeout:
                        print("❌ 超过最大等待时间，点击失败")
                        break
                    else:
                        print("点击被拦截或元素未可点，等待1秒后重试...")
                        time.sleep(interval)

        except Exception as e:
            print(f"❌ Error occurred: {e}")

    def search_entry_num(entry_number, timeout=5):
        driver.switch_to.default_content()

        wait_for_block_to_disappear(driver)
        start_time = time.time()
        while True:
            try:

                find_element = WebDriverWait(driver, 10).until(
                    EC.visibility_of_element_located(
                        (By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/button[2]/span[2]"))
                )
                # 模拟鼠标悬停
                actions = ActionChains(driver)
                actions.move_to_element(find_element).perform()
                # 尝试定位并输入 entry_number
                input_box = WebDriverWait(driver, 3).until(
                    EC.visibility_of_element_located((By.XPATH, "//*[@id='advancedSearch']/div/div[8]/input"))
                )
                input_box.clear()
                input_box.send_keys(entry_number)

                # 尝试点击按钮
                search_button = WebDriverWait(driver, 3).until(
                    EC.element_to_be_clickable(
                        (By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/div[3]/div/div[13]/a[1]"))
                )
                search_button.click()

                break  # 成功后跳出循环

            except (ElementNotInteractableException, NoSuchElementException, TimeoutException) as e:
                if time.time() - start_time > timeout:
                    return "超时"
                    break
                else:
                    time.sleep(1)  # 等待1秒后重试

    def safe_do(driver, action, description="", retries=2, retry_delay=0.5):
        for attempt in range(retries):
            try:
                check_alert(driver)
                result = action()
                check_alert(driver)
                return result
            except Exception as e:
                print(f"⚠️ {description} 第 {attempt + 1} 次尝试失败: {e}")
                check_alert(driver)
                if attempt < retries - 1:
                    time.sleep(retry_delay)
                else:
                    print(f"❌ {description} 所有尝试失败")
                    return "tryfalse"

    def wait_for_autocomplete(driver, xpath: str, interval: float, duration: float):
        import time
        from selenium.common.exceptions import NoSuchElementException
        from selenium.webdriver.common.by import By

        start_time = time.time()

        while time.time() - start_time < duration:
            try:
                element = driver.find_element(By.XPATH, xpath)
                if element.is_displayed():
                    print("✅ 自动补全栏已弹出")
                    time.sleep(1)
                    return True
            except NoSuchElementException:
                print("🔍 未检测到自动补全栏，继续等待...")

            time.sleep(interval)

        print("❌ 超时未检测到自动补全栏")
        return False

    def data_entry(driver, entry_xpath: str, choose_xpath: str, interval: float, duration: float, content: str):
        try:
            # 清空并输入
            safe_do(driver, lambda: WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.XPATH, entry_xpath))).clear(), "清空输入框")
            safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(""), "输入空内容")
            safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(content), "输入内容")

            # 尝试点击自动补全选项
            import time, re
            start_time = time.time()

            # 提取 ul 的索引
            ul_pattern = re.search(r'ul\[(\d+)\]', choose_xpath)
            if not ul_pattern:
                print("❌ choose_xpath 无法识别 ul[x] 的格式")
                return

            base_index = int(ul_pattern.group(1))
            prefix, suffix = choose_xpath.split(f'ul[{base_index}]')

            while time.time() - start_time < duration:
                for i in range(11):  # 最多尝试 base 到 base+10
                    trial_xpath = f"{prefix}ul[{base_index + i}]{suffix}"
                    print(f"尝试点击: {trial_xpath}")
                    result = safe_do(driver, lambda: WebDriverWait(driver, interval).until(
                        EC.element_to_be_clickable((By.XPATH, trial_xpath))).click(),
                                     f"点击自动补全项 ul[{base_index + i}]")

                    if result != "tryfalse":
                        print(f"✅ 点击成功: {trial_xpath}")
                        return

            print("❌ 所有自动补全尝试失败")

        except Exception as e:
            print("❌ data_entry 函数发生异常：", e)
            check_alert(driver)

    def normal_entry(driver, entry_xpath: str, interval: float, duration: float, content: str):

        try:
            safe_do(driver, lambda: WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.XPATH, entry_xpath))).clear(), "清空输入框")
            safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(""), "输入空内容")
            safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(content), "输入内容")

        except Exception as e:
            # 这里捕获其他异常并打印详细信息
            print("❌ 发生其他异常：", e)

    def page_viewd(driver):
        try:
            iframe = driver.find_element(By.ID, "iframeInvoices")
            driver.switch_to.frame(iframe)
        except:
            pass
        safe_do(driver, lambda: WebDriverWait(driver, 10, poll_frequency=0.5).until(
            EC.element_to_be_clickable((By.XPATH,
                                        "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[1]/div[1]/span[2]/ul/li[4]/a"))
        ).click(), "点击某个按钮", retries=20, retry_delay=0.5)
        safe_do(driver, lambda: WebDriverWait(driver, 10, poll_frequency=0.5).until(
            EC.element_to_be_clickable((By.XPATH,
                                        "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[1]/div[1]/span[2]/ul/li[4]/a"))).click(),
                "点击某个按钮", retries=1, retry_delay=0.5)
        wait_for_block_to_disappear(driver, timeout=600, check_interval=1)

        safe_do(driver, lambda: WebDriverWait(driver, 10, poll_frequency=0.5).until(
            EC.element_to_be_clickable((By.XPATH, "//a[contains(@onclick, 'PreviewInvoice')]"))
        ).click(), "点击预览按钮", retries=10, retry_delay=0.5)
        wait_for_block_to_disappear(driver, timeout=600, check_interval=1)

    file_path = os.path.join(desktop_path, "BBCreview.xlsx")
    file_path = file_path
    df = pd.read_excel(file_path, header=None, dtype=str)  # 加 dtype=str 读进来就全是字符串

    # 通过 iloc 访问第一列（假设是 A 列）
    a_column = df.iloc[:, 0]  # 选择第一列

    # 过滤掉 'na' 和 NaN 值
    filtered_lista = a_column[a_column.notna() & (a_column != 'na')].tolist()

    # wait_for_block_to_disappear(driver, timeout=40, check_interval=1)
    # open_entry(driver)
    # for entry_number,house in zip(filtered_lista,filtered_listc):
    #     search_entry_num(entry_number, timeout=5)
    #     wait_for_block_to_disappear(driver, timeout=80, check_interval=1)
    #     check_alert(driver)
    #     # WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/div[3]/div/div[13]/a[2]"))).click()
    #     safe_do(driver, lambda: WebDriverWait(driver, 10).until(
    #         EC.element_to_be_clickable((By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/div[3]/div/div[13]/a[2]"))    ).click(), "点击某个按钮")
    #     page_viewd(driver,house)
    #     safe_do(driver, lambda: WebDriverWait(driver, 10).until(
    #         EC.element_to_be_clickable((By.XPATH, "//html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[1]/div[1]/span[2]/ul/li[1]/a"))    ).click(), "点击某个按钮")
    #     safe_do(driver, lambda: WebDriverWait(driver, 10).until(
    #         EC.element_to_be_clickable((By.XPATH, "//html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[1]/div[1]/span[2]/ul/li[1]/a"))    ).click(), "点击某个按钮")

    #     wait_for_block_to_disappear(driver, timeout=80, check_interval=1)
    #     time.sleep(1)

    wait_for_block_to_disappear(driver, timeout=40, check_interval=1)

    for entry_number in filtered_lista:

        search_entry_num(entry_number, timeout=5)
        wait_for_block_to_disappear(driver, timeout=80, check_interval=1)
        check_alert(driver)
        open_entry(driver)
        safe_do(driver, lambda: WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable(
                (By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/div[3]/div/div[13]/a[2]"))).click(),
                "点击某个按钮")

        page_viewd(driver)
        try:
            driver.switch_to.default_content()
            print("成功切换回来")
        except Exception as e:
            print(f"⚠️ 切换回主页面失败: {e}")
            pass
        safe_do(driver, lambda: WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable(
                (By.XPATH, "/html/body/div[2]/div[2]/div[3]/div/div[1]/div[1]/div[1]/ul/li[36]/span[2]"))).click(),
                "点击某个按钮")
        wait_for_block_to_disappear(driver, timeout=80, check_interval=1)
        time.sleep(1)
        update_output_text(output_text, f"{entry_number}结束")
    update_output_text(output_text, "全部完成")



def release_program(account, password, output_text):
    expiration_date = expiration_date1
    now = datetime.now()
    func_name = inspect.currentframe().f_code.co_name  # 自动获取当前函数名

    if expiration_date and now > expiration_date:
        if not is_user_allowed(func_name, account):
            update_output_text(output_text, "程序已过期，请联系Larry获取更新版本。\n\n")
            exit()

    user_home = os.path.expanduser("~")
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "BBCreview.xlsx")
        if os.path.exists(file_path):
            update_output_text(output_text, f"找到文件：{file_path}\n\n")
        else:
            # 创建空的 Excel 文件
            wb = Workbook()
            wb.save(file_path)
            update_output_text(output_text, f"未找到文件，已创建新文件,下次运行将开始操作：{file_path}\n\n")
            sys.exit()  # 程序立即停止
    else:
        update_output_text(output_text, "未找到有效的桌面路径\n\n")
        sys.exit()  # 程序立即停止

    try:
        options = webdriver.ChromeOptions()
        options.add_argument("--disable-gpu")  # 解决某些系统的图形渲染问题
        options.add_argument("--no-sandbox")  # 非root用户需要此参数
        options.add_argument("--disable-dev-shm-usage")  # 避免某些共享内存问题
        options.add_argument("--always-on-top")  # 窗口置顶 (实验性参数)
        options.add_argument("--force-device-scale-factor=0.5")  # 设置缩放比例为50%
        chrome_binary = r"C:\Program Files\Google\Chrome\Application\chrome.exe"
        options.binary_location = chrome_binary
        options.add_argument("--no-sandbox")
        options.add_argument("--disable-dev-shm-usage")
        if os.path.exists(chrome_binary):
            update_output_text(output_text, f"Chrome 可执行文件存在: {chrome_binary}\n")
        else:
            update_output_text(output_text, f"Chrome 可执行文件不存在: {chrome_binary}\n")
            raise FileNotFoundError(f"Chrome 可执行文件未找到: {chrome_binary}")

        try:
            driver_path = ChromeDriverManager().install()
            update_output_text(output_text, f"ChromeDriver 路径: {driver_path}\n")
            driver_version = subprocess.check_output([driver_path, "--version"]).decode().strip()
            update_output_text(output_text, f"ChromeDriver 版本: {driver_version}\n")
        except Exception as e:
            update_output_text(output_text, f"获取 ChromeDriver 路径或版本失败: {str(e)}\n")
            raise
        system_path = os.environ.get("PATH", "")
        update_output_text(output_text, f"系统 PATH: {system_path}\n")
        update_output_text(output_text, "开始初始化 ChromeDriver...\n")
        driver = webdriver.Chrome(service=Service(driver_path), options=options)

        update_output_text(output_text, "ChromeDriver 初始化成功\n")
    except webdriver.WebDriverException as wde:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (WebDriverException): {str(wde)}\n")
        update_output_text(output_text, f"堆栈跟踪: {traceback.format_exc()}\n")
        raise
    except FileNotFoundError as fnfe:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (FileNotFoundError): {str(fnfe)}\n")
        raise
    except Exception as e:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (未知错误): {str(e)}\n")
        update_output_text(output_text, f"堆栈跟踪: {traceback.format_exc()}\n")
        raise

    # 通过 JavaScript 强制设置缩放比例
    driver.get("https://www.google.com")
    driver.execute_script("document.body.style.zoom='50%'")
    url = "https://my.acelynknavigator.com/Account/Login.aspx?ReturnUrl=%2fDesktop%2fDefault.aspx"
    driver.get(url)
    driver.maximize_window()  # 最大化窗口

    all_tabs = driver.window_handles
    all_tabs = driver.window_handles

    # 遍历所有窗口，关闭不需要的 "data:" 标签页
    for tab in all_tabs:
        driver.switch_to.window(tab)
        if "data:" in driver.current_url:
            driver.close()  # 关闭 "data:" 标签页

    # 重新获取当前所有窗口句柄
    all_tabs = driver.window_handles

    # 如果有剩余窗口，切换到第一个
    if all_tabs:
        driver.switch_to.window(all_tabs[0])

    try:
        # 等待页面加载并检查是否包含 "sign"
        WebDriverWait(driver, 10).until(
            lambda d: "sign" in d.page_source.lower()  # 等待直到页面包含 "sign"
        )
        print("'sign' found in page source. Continuing...")
    except Exception as e:
        print("Timeout or error while waiting for 'sign':", e)
        driver.quit()
        exit()

    # 输入账号和密码
    username = account  # 替换为实际账号
    password = password  # 替换为实际密码

    # 定位到账号和密码输入框
    username_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_UserName"]')
    username_field.clear()  # 清除输入框中的任何内容
    username_field.send_keys(username)  # 输入用户名

    # 输入密码
    password_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_Password"]')
    password_field.clear()  # 清除输入框中的任何内容
    password_field.send_keys(password)  # 输入密码

    # 点击登录按钮
    login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")  # 替换为实际 ID
    login_button.click()
    print("Current page title is:", driver.title)
    WebDriverWait(driver, 10).until(EC.title_contains("Compliance"))  # 等待页面标题更新为登录后的内容

    try:
        # 定位到登录按钮并点击
        login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")
        login_button.click()

        # 等待检查是否有警告框弹出
        try:
            logout_button = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable((By.XPATH, "//*[@id='lbtLogOutAllSessions']"))
            )
            logout_button.click()
            print("Clicked the logout button in the alert.")

            # 等待页面刷新（可以根据 URL 变化或某个标志性元素来确认）
            WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.ID, "LoginMenu_LoginButton"))  # 确保登录按钮存在
            )
            time.sleep(2)
            username_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_UserName"]')
            username_field.clear()  # 清除输入框中的任何内容
            username_field.send_keys(username)  # 输入用户名

            # 输入密码
            password_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_Password"]')
            password_field.clear()  # 清除输入框中的任何内容
            password_field.send_keys(password)  # 输入密码
            # 重新定位登录按钮
            login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")
            login_button.click()
            print("Clicked the login button.")

        except TimeoutException:
            print("No alert appeared, proceeding with the login.")

        # 等待页面跳转并检查登录后页面标题
        WebDriverWait(driver, 10).until(
            EC.title_contains("Dashboard")  # 这里用登录后的页面标题的一个关键字
        )
        print("Login successful. Page title is:", driver.title)

    except (TimeoutException, NoSuchElementException) as e:
        print(f"Error occurred during login: {e}")
    outputdf = pd.DataFrame(columns=["entry_number", "status_img_src", "pga_img_src", "first_column_data"])
    driver.get("https://my.acelynknavigator.com/Desktop/Default.aspx")
    step_status = True

    def check_alert(driver):
        try:
            time.sleep(1)
            alert = driver.switch_to.alert
            alert_text = alert.text
            print("弹窗内容:", alert_text)

            if "cotton" not in alert_text.lower():
                alert.accept()
                print("已点击确认按钮")
            else:
                alert.dismiss()
                print("检测到 'cotton'，已点击取消按钮")

            time.sleep(1)
        except NoAlertPresentException:
            pass  # 没有弹窗，跳过

    def wait_for_block_to_disappear(driver, timeout=40, check_interval=1):
        end_time = time.time() + timeout
        while time.time() < end_time:
            try:
                # 查找遮罩层
                blocking_elements = driver.find_elements(By.CSS_SELECTOR, ".blockUI.blockOverlay")
                if not blocking_elements:
                    print("✅ 阻挡元素消失，继续操作")
                    return
                print("⏳ 检测到遮罩层，等待中...")
                time.sleep(check_interval)
            except UnexpectedAlertPresentException:
                try:
                    alert = driver.switch_to.alert
                    print("⚠️ 检测到 alert 弹窗：", alert.text)
                    alert.accept()
                    print("✅ 已点击确认关闭 alert")
                    time.sleep(1)
                except NoAlertPresentException:
                    print("❌ 想处理 alert，但找不到")
                continue
            except Exception as e:
                print(f"⚠️ 检测遮罩层时出现错误: {e}")
                time.sleep(check_interval)
                continue

    def open_entry(driver):
        try:
            driver.switch_to.default_content()
            print("✅ 已返回主页面")
        except Exception as e:
            print(f"❌ 返回主页面失败: {e}")

        try:
            # 检查 iframe
            iframes = driver.find_elements(By.TAG_NAME, "iframe")
            print(f"🔎 检测到 {len(iframes)} 个 iframe")
            iframe_switched = False
            if iframes:
                for i, iframe in enumerate(iframes):
                    try:
                        driver.switch_to.frame(iframe)
                        print(f"✅ 切换到 iframe {i}")
                        driver.find_element(By.XPATH,
                                            "(//td[contains(@id, 'EntrySummary')]//ul[@class='nav2']//img)[1]")
                        print("✅ 悬停元素在 iframe 中")
                        iframe_switched = True
                        break
                    except:
                        driver.switch_to.default_content()
                        print(f"❌ iframe {i} 中无目标元素，切换回主页面")
            else:
                print("✅ 无 iframe")

            # 定位悬停元素并提取 <td> 的 id
            img_xpath = "(//td[contains(@id, 'EntrySummary')]//ul[@class='nav2']//img)[1]"
            print(f"🔍 尝试定位悬停元素: {img_xpath}")
            img_elements = driver.find_elements(By.XPATH, img_xpath)
            print(f"🔎 找到 {len(img_elements)} 个悬停元素")
            if len(img_elements) > 1:
                print("⚠️ 警告: 悬停 XPath 匹配到多个元素，可能导致错误")
                for i, elem in enumerate(img_elements):
                    print(f"🔎 悬停元素 {i}: {elem.get_attribute('outerHTML')}")
            img_element = img_elements[0] if img_elements else driver.find_element(By.XPATH, img_xpath)
            print(f"✅ 悬停元素: {img_element.get_attribute('outerHTML')}")

            # 获取父 <td> 的 id
            td_element = img_element.find_element(By.XPATH, "./ancestor::td[contains(@id, 'EntrySummary')]")
            td_id = td_element.get_attribute("id")
            print(f"✅ 找到父 <td> id: {td_id}")

            # 悬停并等待菜单加载
            ActionChains(driver).move_to_element(img_element).perform()
            print("✅ 已执行悬停操作")
            try:
                WebDriverWait(driver, 5).until(
                    EC.presence_of_element_located((By.XPATH, "//a[contains(@class,'shipment-row')]"))
                )
                print("✅ 菜单已加载")
            except TimeoutException:
                print("❌ 菜单未加载，可能悬停失败")

            # 检查弹窗
            def check_alert(driver):
                try:
                    alert = driver.switch_to.alert
                    alert.accept()
                    print("✅ 已关闭弹窗")
                except:
                    print("✅ 无弹窗")

            check_alert(driver)

            # 检查高 z-index 元素
            overlays = driver.find_elements(By.XPATH,
                                            "//*[contains(@style, 'z-index') and not(contains(@style, 'z-index: 0'))]")
            print(f"🔎 检测到 {len(overlays)} 个高 z-index 元素")
            for overlay in overlays[:3]:
                print(f"🔎 覆盖层: {overlay.get_attribute('outerHTML')}")

            # 定位 Edit 按钮，使用父 <td> 的 id 约束
            timeout = 10
            interval = 1
            start_time = time.time()
            edit_xpath = f"//td[@id='{td_id}']//a[contains(@class,'shipment-row') and .//img[contains(@src,'edit_30x30.png')]]"
            print(f"🔍 尝试定位 Edit 按钮: {edit_xpath}")
            edit_elements = driver.find_elements(By.XPATH, edit_xpath)
            print(f"🔎 找到 {len(edit_elements)} 个 Edit 按钮")
            if len(edit_elements) > 1:
                print("⚠️ 警告: Edit XPath 仍匹配到多个元素")
                for i, elem in enumerate(edit_elements):
                    print(f"🔎 Edit 按钮 {i}: {elem.get_attribute('outerHTML')}")
            elif len(edit_elements) == 0:
                print("❌ Edit 按钮未找到，XPath 可能错误或元素未加载")
                print(
                    "🔍 尝试备用 XPath: //a[contains(@class,'shipment-row') and .//img[contains(@src,'edit_30x30.png')]]")
                edit_elements = driver.find_elements(By.XPATH,
                                                     "//a[contains(@class,'shipment-row') and .//img[contains(@src,'edit_30x30.png')]]")
                print(f"🔎 备用 XPath 找到 {len(edit_elements)} 个 Edit 按钮")
                for i, elem in enumerate(edit_elements):
                    print(f"🔎 备用 Edit 按钮 {i}: {elem.get_attribute('outerHTML')}")

            while True:
                try:
                    edit_img = WebDriverWait(driver, interval).until(
                        EC.element_to_be_clickable((By.XPATH, edit_xpath))
                    )
                    print(f"✅ Edit 按钮定位成功: {edit_img.get_attribute('outerHTML')}")
                    print(f"🔎 元素可见: {edit_img.is_displayed()}, 元素可点击: {edit_img.is_enabled()}")
                    try:
                        edit_img.click()
                        print("✅ 点击 Edit 按钮成功")
                        break
                    except ElementClickInterceptedException as e:
                        print(f"❌ 点击被拦截: {e}")
                        print("🔍 尝试 JavaScript 点击")
                        driver.execute_script("arguments[0].click();", edit_img)
                        print("✅ 使用 JavaScript 点击 Edit 按钮")
                        break
                except TimeoutException as e:
                    elapsed = time.time() - start_time
                    print(f"❌ TimeoutException: {e}")
                    if elapsed >= timeout:
                        print("❌ 超过最大等待时间，点击失败")
                        print("📄 当前页面 HTML（部分）:")
                        edit_elements = driver.find_elements(By.XPATH, edit_xpath)
                        if edit_elements:
                            print(f"🔎 Edit 按钮存在但不可点击: {edit_elements[0].get_attribute('outerHTML')}")
                        else:
                            print("🔎 Edit 按钮未在 DOM 中找到")
                        break
                    else:
                        print("❌ 元素未可点，等待1秒后重试...")
                        time.sleep(interval)
                except ElementClickInterceptedException as e:
                    elapsed = time.time() - start_time
                    print(f"❌ ElementClickInterceptedException: {e}")
                    if elapsed >= timeout:
                        print("❌ 超过最大等待时间，点击失败")
                        print("📄 当前页面 HTML（部分）:")
                        edit_elements = driver.find_elements(By.XPATH, edit_xpath)
                        if edit_elements:
                            print(f"🔎 Edit 按钮存在但被遮挡: {edit_elements[0].get_attribute('outerHTML')}")
                        break
                    else:
                        print("❌ 元素被拦截，等待1秒后重试...")
                        time.sleep(interval)

            # 切换回主页面
            if iframe_switched:
                driver.switch_to.default_content()
                print("✅ 切换回主页面")

        except Exception as e:
            print(f"❌ 发生错误: {e}")
            print("📄 当前页面 HTML（部分）:")
            edit_elements = driver.find_elements(By.XPATH, edit_xpath)
            if edit_elements:
                print(f"🔎 Edit 按钮: {edit_elements[0].get_attribute('outerHTML')}")
            else:
                print("🔎 Edit 按钮未找到")

    def search_entry_num(entry_number, timeout=5):
        driver.switch_to.default_content()

        wait_for_block_to_disappear(driver)
        start_time = time.time()
        while True:
            try:

                find_element = WebDriverWait(driver, 10).until(
                    EC.visibility_of_element_located(
                        (By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/button[2]/span[2]"))
                )
                # 模拟鼠标悬停
                actions = ActionChains(driver)
                actions.move_to_element(find_element).perform()
                # 尝试定位并输入 entry_number
                input_box = WebDriverWait(driver, 3).until(
                    EC.visibility_of_element_located((By.XPATH, "//*[@id='advancedSearch']/div/div[8]/input"))
                )
                input_box.clear()
                input_box.send_keys(entry_number)

                # 尝试点击按钮
                search_button = WebDriverWait(driver, 3).until(
                    EC.element_to_be_clickable(
                        (By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/div[3]/div/div[13]/a[1]"))
                )
                search_button.click()

                break  # 成功后跳出循环

            except (ElementNotInteractableException, NoSuchElementException, TimeoutException) as e:
                if time.time() - start_time > timeout:
                    return "超时"
                    break
                else:
                    time.sleep(1)  # 等待1秒后重试

    def safe_do(driver, action, description="", retries=2, retry_delay=0.5):
        for attempt in range(retries):
            try:
                check_alert(driver)
                result = action()
                check_alert(driver)
                return result
            except Exception as e:
                print(f"⚠️ {description} 第 {attempt + 1} 次尝试失败: {e}")
                check_alert(driver)
                if attempt < retries - 1:
                    time.sleep(retry_delay)
                else:
                    print(f"❌ {description} 所有尝试失败")
                    return "tryfalse"

    def wait_for_autocomplete(driver, xpath: str, interval: float, duration: float):
        import time
        from selenium.common.exceptions import NoSuchElementException
        from selenium.webdriver.common.by import By

        start_time = time.time()

        while time.time() - start_time < duration:
            try:
                element = driver.find_element(By.XPATH, xpath)
                if element.is_displayed():
                    print("✅ 自动补全栏已弹出")
                    time.sleep(1)
                    return True
            except NoSuchElementException:
                print("🔍 未检测到自动补全栏，继续等待...")

            time.sleep(interval)

        print("❌ 超时未检测到自动补全栏")
        return False

    def data_entry(driver, entry_xpath: str, choose_xpath: str, interval: float, duration: float, content: str):
        try:
            # 清空并输入
            safe_do(driver, lambda: WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.XPATH, entry_xpath))).clear(), "清空输入框")
            safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(""), "输入空内容")
            safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(content), "输入内容")

            # 尝试点击自动补全选项
            import time, re
            start_time = time.time()

            # 提取 ul 的索引
            ul_pattern = re.search(r'ul\[(\d+)\]', choose_xpath)
            if not ul_pattern:
                print("❌ choose_xpath 无法识别 ul[x] 的格式")
                return

            base_index = int(ul_pattern.group(1))
            prefix, suffix = choose_xpath.split(f'ul[{base_index}]')

            while time.time() - start_time < duration:
                for i in range(11):  # 最多尝试 base 到 base+10
                    trial_xpath = f"{prefix}ul[{base_index + i}]{suffix}"
                    print(f"尝试点击: {trial_xpath}")
                    result = safe_do(driver, lambda: WebDriverWait(driver, interval).until(
                        EC.element_to_be_clickable((By.XPATH, trial_xpath))).click(),
                                     f"点击自动补全项 ul[{base_index + i}]")

                    if result != "tryfalse":
                        print(f"✅ 点击成功: {trial_xpath}")
                        return

            print("❌ 所有自动补全尝试失败")

        except Exception as e:
            print("❌ data_entry 函数发生异常：", e)
            check_alert(driver)

    def normal_entry(driver, entry_xpath: str, interval: float, duration: float, content: str):

        try:
            safe_do(driver, lambda: WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.XPATH, entry_xpath))).clear(), "清空输入框")
            safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(""), "输入空内容")
            safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(content), "输入内容")

        except Exception as e:
            # 这里捕获其他异常并打印详细信息
            print("❌ 发生其他异常：", e)

    def page_viewd(driver):
        try:
            iframe = driver.find_element(By.ID, "iframeInvoices")
            driver.switch_to.frame(iframe)
        except:
            pass
        safe_do(driver, lambda: WebDriverWait(driver, 10, poll_frequency=0.5).until(
            EC.element_to_be_clickable((By.XPATH,
                                        "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[1]/div[1]/span[2]/ul/li[4]/a"))
        ).click(), "点击某个按钮", retries=20, retry_delay=0.5)
        safe_do(driver, lambda: WebDriverWait(driver, 10, poll_frequency=0.5).until(
            EC.element_to_be_clickable((By.XPATH,
                                        "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[1]/div[1]/span[2]/ul/li[4]/a"))).click(),
                "点击某个按钮", retries=1, retry_delay=0.5)
        wait_for_block_to_disappear(driver, timeout=600, check_interval=1)

        try:
            checkbox = driver.find_element(By.ID, "IsBatchProcessing")

            # 用 JS 取消 disabled 和 checked
            driver.execute_script("""
                arguments[0].removeAttribute('disabled');
            """, checkbox)

            # 点击一下勾上

            driver.execute_script("""
                arguments[0].checked = false;
            """, checkbox)

            print("✅ 已成功解锁并勾选 checkbox")
        except Exception as e:
            print(f"❌ 解锁勾选 checkbox 失败: {e}")
        safe_do(driver, lambda: WebDriverWait(driver, 10, poll_frequency=0.5).until(
            EC.element_to_be_clickable((By.XPATH, "//a[contains(@onclick, 'SubmitValidatedInvoice')]"))
        ).click())
        wait_for_block_to_disappear(driver, timeout=600, check_interval=1)

    file_path = os.path.join(desktop_path, "BBCreview.xlsx")
    file_path = file_path
    df = pd.read_excel(file_path, header=None, dtype=str)  # 加 dtype=str 读进来就全是字符串

    # 通过 iloc 访问第一列（假设是 A 列）
    a_column = df.iloc[:, 0]  # 选择第一列

    # 过滤掉 'na' 和 NaN 值
    filtered_lista = a_column[a_column.notna() & (a_column != 'na')].tolist()
    update_output_text(output_text, f"所有要处理的inbond: {filtered_lista}\n\n\n")
    # wait_for_block_to_disappear(driver, timeout=40, check_interval=1)
    # open_entry(driver)
    # for entry_number,house in zip(filtered_lista,filtered_listc):
    #     search_entry_num(entry_number, timeout=5)
    #     wait_for_block_to_disappear(driver, timeout=80, check_interval=1)
    #     check_alert(driver)
    #     # WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/div[3]/div/div[13]/a[2]"))).click()
    #     safe_do(driver, lambda: WebDriverWait(driver, 10).until(
    #         EC.element_to_be_clickable((By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/div[3]/div/div[13]/a[2]"))    ).click(), "点击某个按钮")
    #     page_viewd(driver,house)
    #     safe_do(driver, lambda: WebDriverWait(driver, 10).until(
    #         EC.element_to_be_clickable((By.XPATH, "//html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[1]/div[1]/span[2]/ul/li[1]/a"))    ).click(), "点击某个按钮")
    #     safe_do(driver, lambda: WebDriverWait(driver, 10).until(
    #         EC.element_to_be_clickable((By.XPATH, "//html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[1]/div[1]/span[2]/ul/li[1]/a"))    ).click(), "点击某个按钮")

    #     wait_for_block_to_disappear(driver, timeout=80, check_interval=1)
    #     time.sleep(1)

    wait_for_block_to_disappear(driver, timeout=40, check_interval=1)

    for entry_number in filtered_lista:

        search_entry_num(entry_number, timeout=5)
        wait_for_block_to_disappear(driver, timeout=80, check_interval=1)
        check_alert(driver)
        open_entry(driver)
        safe_do(driver, lambda: WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable(
                (By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/div[3]/div/div[13]/a[2]"))).click(),
                "点击某个按钮")

        page_viewd(driver)
        try:
            driver.switch_to.default_content()
            print("成功切换回来")
        except Exception as e:
            print(f"⚠️ 切换回主页面失败: {e}")
            pass
        safe_do(driver, lambda: WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable(
                (By.XPATH, "/html/body/div[2]/div[2]/div[3]/div/div[1]/div[1]/div[1]/ul/li[36]/span[2]"))).click(),
                "点击某个按钮")
        wait_for_block_to_disappear(driver, timeout=80, check_interval=1)
        time.sleep(1)
        update_output_text(output_text, f"{entry_number}结束")
    update_output_text(output_text, "全部完成")

def bolupdate_program(account, password, output_text):
    expiration_date = expiration_date1
    now = datetime.now()
    func_name = inspect.currentframe().f_code.co_name  # 自动获取当前函数名

    if expiration_date and now > expiration_date:
        if not is_user_allowed(func_name, account):
            update_output_text(output_text, "程序已过期，请联系Larry获取更新版本。\n\n")
            exit()

    user_home = os.path.expanduser("~")
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "BBCreview.xlsx")
        if os.path.exists(file_path):
            update_output_text(output_text, f"找到文件：{file_path}\n\n")
        else:
            # 创建空的 Excel 文件
            wb = Workbook()
            wb.save(file_path)
            update_output_text(output_text, f"未找到文件，已创建新文件,下次运行将开始操作：{file_path}\n\n")
            sys.exit()  # 程序立即停止
    else:
        update_output_text(output_text, "未找到有效的桌面路径\n\n")
        sys.exit()  # 程序立即停止

    chrome_options = webdriver.ChromeOptions()
    chrome_options.add_argument("--start-maximized")  # 启动时最大化
    chrome_options.add_argument("--disable-gpu")  # 解决某些系统的图形渲染问题
    chrome_options.add_argument("--no-sandbox")  # 非root用户需要此参数
    chrome_options.add_argument("--disable-dev-shm-usage")  # 避免某些共享内存问题
    chrome_options.add_argument("--always-on-top")  # 窗口置顶 (实验性参数)
    chrome_options.add_argument("--force-device-scale-factor=0.5")  # 设置缩放比例为50%

    # 启动 Chrome 浏览器并加载已保存的用户数据
    driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=chrome_options)
    driver.set_window_size(1920, 1080)

    # 通过 JavaScript 强制设置缩放比例
    driver.get("https://www.google.com")
    driver.execute_script("document.body.style.zoom='50%'")
    url = "https://my.acelynknavigator.com/Account/Login.aspx?ReturnUrl=%2fDesktop%2fDefault.aspx"
    driver.get(url)
    driver.maximize_window()  # 最大化窗口

    all_tabs = driver.window_handles
    all_tabs = driver.window_handles

    # 遍历所有窗口，关闭不需要的 "data:" 标签页
    for tab in all_tabs:
        driver.switch_to.window(tab)
        if "data:" in driver.current_url:
            driver.close()  # 关闭 "data:" 标签页

    # 重新获取当前所有窗口句柄
    all_tabs = driver.window_handles

    # 如果有剩余窗口，切换到第一个
    if all_tabs:
        driver.switch_to.window(all_tabs[0])

    try:
        # 等待页面加载并检查是否包含 "sign"
        WebDriverWait(driver, 10).until(
            lambda d: "sign" in d.page_source.lower()  # 等待直到页面包含 "sign"
        )
        print("'sign' found in page source. Continuing...")
    except Exception as e:
        print("Timeout or error while waiting for 'sign':", e)
        driver.quit()
        exit()

    # 输入账号和密码
    username = account  # 替换为实际账号
    password = password  # 替换为实际密码

    # 定位到账号和密码输入框
    username_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_UserName"]')
    username_field.clear()  # 清除输入框中的任何内容
    username_field.send_keys(username)  # 输入用户名

    # 输入密码
    password_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_Password"]')
    password_field.clear()  # 清除输入框中的任何内容
    password_field.send_keys(password)  # 输入密码

    # 点击登录按钮
    login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")  # 替换为实际 ID
    login_button.click()
    print("Current page title is:", driver.title)
    WebDriverWait(driver, 10).until(EC.title_contains("Compliance"))  # 等待页面标题更新为登录后的内容

    try:
        # 定位到登录按钮并点击
        login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")
        login_button.click()

        # 等待检查是否有警告框弹出
        try:
            logout_button = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable((By.XPATH, "//*[@id='lbtLogOutAllSessions']"))
            )
            logout_button.click()
            print("Clicked the logout button in the alert.")

            # 等待页面刷新（可以根据 URL 变化或某个标志性元素来确认）
            WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.ID, "LoginMenu_LoginButton"))  # 确保登录按钮存在
            )
            time.sleep(2)
            username_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_UserName"]')
            username_field.clear()  # 清除输入框中的任何内容
            username_field.send_keys(username)  # 输入用户名

            # 输入密码
            password_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_Password"]')
            password_field.clear()  # 清除输入框中的任何内容
            password_field.send_keys(password)  # 输入密码
            # 重新定位登录按钮
            login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")
            login_button.click()
            print("Clicked the login button.")

        except TimeoutException:
            print("No alert appeared, proceeding with the login.")

        # 等待页面跳转并检查登录后页面标题
        WebDriverWait(driver, 10).until(
            EC.title_contains("Dashboard")  # 这里用登录后的页面标题的一个关键字
        )
        print("Login successful. Page title is:", driver.title)

    except (TimeoutException, NoSuchElementException) as e:
        print(f"Error occurred during login: {e}")
    outputdf = pd.DataFrame(columns=["entry_number", "status_img_src", "pga_img_src", "first_column_data"])
    driver.get("https://my.acelynknavigator.com/Desktop/Default.aspx")
    step_status = True

    def check_alert(driver):
        try:
            time.sleep(1)
            alert = driver.switch_to.alert
            alert_text = alert.text
            print("弹窗内容:", alert_text)

            if "cotton" not in alert_text.lower():
                alert.accept()
                print("已点击确认按钮")
            else:
                alert.dismiss()
                print("检测到 'cotton'，已点击取消按钮")

            time.sleep(1)
        except NoAlertPresentException:
            pass  # 没有弹窗，跳过

    def wait_for_block_to_disappear(driver, timeout=40, check_interval=1):
        end_time = time.time() + timeout
        while time.time() < end_time:
            try:
                # 查找遮罩层
                blocking_elements = driver.find_elements(By.CSS_SELECTOR, ".blockUI.blockOverlay")
                if not blocking_elements:
                    print("✅ 阻挡元素消失，继续操作")
                    return
                print("⏳ 检测到遮罩层，等待中...")
                time.sleep(check_interval)
            except UnexpectedAlertPresentException:
                try:
                    alert = driver.switch_to.alert
                    print("⚠️ 检测到 alert 弹窗：", alert.text)
                    alert.accept()
                    print("✅ 已点击确认关闭 alert")
                    time.sleep(1)
                except NoAlertPresentException:
                    print("❌ 想处理 alert，但找不到")
                continue
            except Exception as e:
                print(f"⚠️ 检测遮罩层时出现错误: {e}")
                time.sleep(check_interval)
                continue

    def open_entry(driver):
        try:
            driver.switch_to.default_content()
            print("✅ 已返回主页面")
        except Exception as e:
            print(f"❌ 返回主页面失败: {e}")

        try:
            # 检查 iframe
            iframes = driver.find_elements(By.TAG_NAME, "iframe")
            print(f"🔎 检测到 {len(iframes)} 个 iframe")
            iframe_switched = False
            if iframes:
                for i, iframe in enumerate(iframes):
                    try:
                        driver.switch_to.frame(iframe)
                        print(f"✅ 切换到 iframe {i}")
                        driver.find_element(By.XPATH,
                                            "(//td[contains(@id, 'EntrySummary')]//ul[@class='nav2']//img)[1]")
                        print("✅ 悬停元素在 iframe 中")
                        iframe_switched = True
                        break
                    except:
                        driver.switch_to.default_content()
                        print(f"❌ iframe {i} 中无目标元素，切换回主页面")
            else:
                print("✅ 无 iframe")

            # 定位悬停元素并提取 <td> 的 id
            img_xpath = "(//td[contains(@id, 'EntrySummary')]//ul[@class='nav2']//img)[1]"
            print(f"🔍 尝试定位悬停元素: {img_xpath}")
            img_elements = driver.find_elements(By.XPATH, img_xpath)
            print(f"🔎 找到 {len(img_elements)} 个悬停元素")
            if len(img_elements) > 1:
                print("⚠️ 警告: 悬停 XPath 匹配到多个元素，可能导致错误")
                for i, elem in enumerate(img_elements):
                    print(f"🔎 悬停元素 {i}: {elem.get_attribute('outerHTML')}")
            img_element = img_elements[0] if img_elements else driver.find_element(By.XPATH, img_xpath)
            print(f"✅ 悬停元素: {img_element.get_attribute('outerHTML')}")

            # 获取父 <td> 的 id
            td_element = img_element.find_element(By.XPATH, "./ancestor::td[contains(@id, 'EntrySummary')]")
            td_id = td_element.get_attribute("id")
            print(f"✅ 找到父 <td> id: {td_id}")

            # 悬停并等待菜单加载
            ActionChains(driver).move_to_element(img_element).perform()
            print("✅ 已执行悬停操作")
            try:
                WebDriverWait(driver, 5).until(
                    EC.presence_of_element_located((By.XPATH, "//a[contains(@class,'shipment-row')]"))
                )
                print("✅ 菜单已加载")
            except TimeoutException:
                print("❌ 菜单未加载，可能悬停失败")

            # 检查弹窗
            def check_alert(driver):
                try:
                    alert = driver.switch_to.alert
                    alert.accept()
                    print("✅ 已关闭弹窗")
                except:
                    print("✅ 无弹窗")

            check_alert(driver)

            # 检查高 z-index 元素
            overlays = driver.find_elements(By.XPATH,
                                            "//*[contains(@style, 'z-index') and not(contains(@style, 'z-index: 0'))]")
            print(f"🔎 检测到 {len(overlays)} 个高 z-index 元素")
            for overlay in overlays[:3]:
                print(f"🔎 覆盖层: {overlay.get_attribute('outerHTML')}")

            # 定位 Edit 按钮，使用父 <td> 的 id 约束
            timeout = 10
            interval = 1
            start_time = time.time()
            edit_xpath = f"//td[@id='{td_id}']//a[contains(@class,'shipment-row') and .//img[contains(@src,'edit_30x30.png')]]"
            print(f"🔍 尝试定位 Edit 按钮: {edit_xpath}")
            edit_elements = driver.find_elements(By.XPATH, edit_xpath)
            print(f"🔎 找到 {len(edit_elements)} 个 Edit 按钮")
            if len(edit_elements) > 1:
                print("⚠️ 警告: Edit XPath 仍匹配到多个元素")
                for i, elem in enumerate(edit_elements):
                    print(f"🔎 Edit 按钮 {i}: {elem.get_attribute('outerHTML')}")
            elif len(edit_elements) == 0:
                print("❌ Edit 按钮未找到，XPath 可能错误或元素未加载")
                print(
                    "🔍 尝试备用 XPath: //a[contains(@class,'shipment-row') and .//img[contains(@src,'edit_30x30.png')]]")
                edit_elements = driver.find_elements(By.XPATH,
                                                     "//a[contains(@class,'shipment-row') and .//img[contains(@src,'edit_30x30.png')]]")
                print(f"🔎 备用 XPath 找到 {len(edit_elements)} 个 Edit 按钮")
                for i, elem in enumerate(edit_elements):
                    print(f"🔎 备用 Edit 按钮 {i}: {elem.get_attribute('outerHTML')}")

            while True:
                try:
                    edit_img = WebDriverWait(driver, interval).until(
                        EC.element_to_be_clickable((By.XPATH, edit_xpath))
                    )
                    print(f"✅ Edit 按钮定位成功: {edit_img.get_attribute('outerHTML')}")
                    print(f"🔎 元素可见: {edit_img.is_displayed()}, 元素可点击: {edit_img.is_enabled()}")
                    try:
                        edit_img.click()
                        print("✅ 点击 Edit 按钮成功")
                        break
                    except ElementClickInterceptedException as e:
                        print(f"❌ 点击被拦截: {e}")
                        print("🔍 尝试 JavaScript 点击")
                        driver.execute_script("arguments[0].click();", edit_img)
                        print("✅ 使用 JavaScript 点击 Edit 按钮")
                        break
                except TimeoutException as e:
                    elapsed = time.time() - start_time
                    print(f"❌ TimeoutException: {e}")
                    if elapsed >= timeout:
                        print("❌ 超过最大等待时间，点击失败")
                        print("📄 当前页面 HTML（部分）:")
                        edit_elements = driver.find_elements(By.XPATH, edit_xpath)
                        if edit_elements:
                            print(f"🔎 Edit 按钮存在但不可点击: {edit_elements[0].get_attribute('outerHTML')}")
                        else:
                            print("🔎 Edit 按钮未在 DOM 中找到")
                        break
                    else:
                        print("❌ 元素未可点，等待1秒后重试...")
                        time.sleep(interval)
                except ElementClickInterceptedException as e:
                    elapsed = time.time() - start_time
                    print(f"❌ ElementClickInterceptedException: {e}")
                    if elapsed >= timeout:
                        print("❌ 超过最大等待时间，点击失败")
                        print("📄 当前页面 HTML（部分）:")
                        edit_elements = driver.find_elements(By.XPATH, edit_xpath)
                        if edit_elements:
                            print(f"🔎 Edit 按钮存在但被遮挡: {edit_elements[0].get_attribute('outerHTML')}")
                        break
                    else:
                        print("❌ 元素被拦截，等待1秒后重试...")
                        time.sleep(interval)

            # 切换回主页面
            if iframe_switched:
                driver.switch_to.default_content()
                print("✅ 切换回主页面")

        except Exception as e:
            print(f"❌ 发生错误: {e}")
            print("📄 当前页面 HTML（部分）:")
            edit_elements = driver.find_elements(By.XPATH, edit_xpath)
            if edit_elements:
                print(f"🔎 Edit 按钮: {edit_elements[0].get_attribute('outerHTML')}")
            else:
                print("🔎 Edit 按钮未找到")

    def search_entry_num(entry_number, timeout=5):
        driver.switch_to.default_content()

        wait_for_block_to_disappear(driver)
        start_time = time.time()
        while True:
            try:

                find_element = WebDriverWait(driver, 10).until(
                    EC.visibility_of_element_located(
                        (By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/button[2]/span[2]"))
                )
                # 模拟鼠标悬停
                actions = ActionChains(driver)
                actions.move_to_element(find_element).perform()
                # 尝试定位并输入 entry_number
                input_box = WebDriverWait(driver, 3).until(
                    EC.visibility_of_element_located((By.XPATH, "//*[@id='advancedSearch']/div/div[8]/input"))
                )
                input_box.clear()
                input_box.send_keys(entry_number)

                # 尝试点击按钮
                search_button = WebDriverWait(driver, 3).until(
                    EC.element_to_be_clickable(
                        (By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/div[3]/div/div[13]/a[1]"))
                )
                search_button.click()

                break  # 成功后跳出循环

            except (ElementNotInteractableException, NoSuchElementException, TimeoutException) as e:
                if time.time() - start_time > timeout:
                    return "超时"
                    break
                else:
                    time.sleep(1)  # 等待1秒后重试

    def safe_do(driver, action, description="", retries=2, retry_delay=0.5):
        for attempt in range(retries):
            try:
                check_alert(driver)
                result = action()
                check_alert(driver)
                return result
            except Exception as e:
                print(f"⚠️ {description} 第 {attempt + 1} 次尝试失败: {e}")
                check_alert(driver)
                if attempt < retries - 1:
                    time.sleep(retry_delay)
                else:
                    print(f"❌ {description} 所有尝试失败")
                    return "tryfalse"

    def wait_for_autocomplete(driver, xpath: str, interval: float, duration: float):
        import time
        from selenium.common.exceptions import NoSuchElementException
        from selenium.webdriver.common.by import By

        start_time = time.time()

        while time.time() - start_time < duration:
            try:
                element = driver.find_element(By.XPATH, xpath)
                if element.is_displayed():
                    print("✅ 自动补全栏已弹出")
                    time.sleep(1)
                    return True
            except NoSuchElementException:
                print("🔍 未检测到自动补全栏，继续等待...")

            time.sleep(interval)

        print("❌ 超时未检测到自动补全栏")
        return False

    def data_entry(driver, entry_xpath: str, choose_xpath: str, interval: float, duration: float, content: str):
        try:
            # 清空并输入
            safe_do(driver, lambda: WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.XPATH, entry_xpath))).clear(), "清空输入框")
            safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(""), "输入空内容")
            safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(content), "输入内容")

            # 尝试点击自动补全选项
            import time, re
            start_time = time.time()

            # 提取 ul 的索引
            ul_pattern = re.search(r'ul\[(\d+)\]', choose_xpath)
            if not ul_pattern:
                print("❌ choose_xpath 无法识别 ul[x] 的格式")
                return

            base_index = int(ul_pattern.group(1))
            prefix, suffix = choose_xpath.split(f'ul[{base_index}]')

            while time.time() - start_time < duration:
                for i in range(11):  # 最多尝试 base 到 base+10
                    trial_xpath = f"{prefix}ul[{base_index + i}]{suffix}"
                    print(f"尝试点击: {trial_xpath}")
                    result = safe_do(driver, lambda: WebDriverWait(driver, interval).until(
                        EC.element_to_be_clickable((By.XPATH, trial_xpath))).click(),
                                     f"点击自动补全项 ul[{base_index + i}]")

                    if result != "tryfalse":
                        print(f"✅ 点击成功: {trial_xpath}")
                        return

            print("❌ 所有自动补全尝试失败")

        except Exception as e:
            print("❌ data_entry 函数发生异常：", e)
            check_alert(driver)

    def normal_entry(driver, entry_xpath: str, interval: float, duration: float, content: str):

        try:
            safe_do(driver, lambda: WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.XPATH, entry_xpath))).clear(), "清空输入框")
            safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(""), "输入空内容")
            safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(content), "输入内容")

        except Exception as e:
            # 这里捕获其他异常并打印详细信息
            print("❌ 发生其他异常：", e)

    def page_viewd(driver):
        try:
            iframe = driver.find_element(By.ID, "iframeInvoices")
            driver.switch_to.frame(iframe)
        except:
            pass
        safe_do(driver, lambda: WebDriverWait(driver, 10, poll_frequency=0.5).until(
            EC.element_to_be_clickable((By.XPATH,
                                        "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[1]/div[1]/span[2]/ul/li[4]/a"))
        ).click(), "点击某个按钮", retries=20, retry_delay=0.5)
        safe_do(driver, lambda: WebDriverWait(driver, 10, poll_frequency=0.5).until(
            EC.element_to_be_clickable((By.XPATH,
                                        "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[1]/div[1]/span[2]/ul/li[4]/a"))).click(),
                "点击某个按钮", retries=1, retry_delay=0.5)
        wait_for_block_to_disappear(driver, timeout=600, check_interval=1)

        safe_do(driver, lambda: WebDriverWait(driver, 10, poll_frequency=0.5).until(
            EC.element_to_be_clickable((By.XPATH, "//a[contains(@onclick, 'UpdateACEBOL')]"))
        ).click())
        wait_for_block_to_disappear(driver, timeout=600, check_interval=1)

    file_path = os.path.join(desktop_path, "BBCreview.xlsx")
    file_path = file_path
    df = pd.read_excel(file_path, header=None, dtype=str)  # 加 dtype=str 读进来就全是字符串

    # 通过 iloc 访问第一列（假设是 A 列）
    a_column = df.iloc[:, 0]  # 选择第一列

    # 过滤掉 'na' 和 NaN 值
    filtered_lista = a_column[a_column.notna() & (a_column != 'na')].tolist()
    update_output_text(output_text, f"所有要处理的inbond: {filtered_lista}\n\n\n")
    # wait_for_block_to_disappear(driver, timeout=40, check_interval=1)
    # open_entry(driver)
    # for entry_number,house in zip(filtered_lista,filtered_listc):
    #     search_entry_num(entry_number, timeout=5)
    #     wait_for_block_to_disappear(driver, timeout=80, check_interval=1)
    #     check_alert(driver)
    #     # WebDriverWait(driver, 10).until(EC.element_to_be_clickable((By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/div[3]/div/div[13]/a[2]"))).click()
    #     safe_do(driver, lambda: WebDriverWait(driver, 10).until(
    #         EC.element_to_be_clickable((By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/div[3]/div/div[13]/a[2]"))    ).click(), "点击某个按钮")
    #     page_viewd(driver,house)
    #     safe_do(driver, lambda: WebDriverWait(driver, 10).until(
    #         EC.element_to_be_clickable((By.XPATH, "//html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[1]/div[1]/span[2]/ul/li[1]/a"))    ).click(), "点击某个按钮")
    #     safe_do(driver, lambda: WebDriverWait(driver, 10).until(
    #         EC.element_to_be_clickable((By.XPATH, "//html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[1]/div[1]/span[2]/ul/li[1]/a"))    ).click(), "点击某个按钮")

    #     wait_for_block_to_disappear(driver, timeout=80, check_interval=1)
    #     time.sleep(1)

    wait_for_block_to_disappear(driver, timeout=40, check_interval=1)

    for entry_number in filtered_lista:

        search_entry_num(entry_number, timeout=5)
        wait_for_block_to_disappear(driver, timeout=80, check_interval=1)
        check_alert(driver)
        open_entry(driver)
        safe_do(driver, lambda: WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable(
                (By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/div[3]/div/div[13]/a[2]"))).click(),
                "点击某个按钮")

        page_viewd(driver)
        try:
            driver.switch_to.default_content()
            print("成功切换回来")
        except Exception as e:
            print(f"⚠️ 切换回主页面失败: {e}")
            pass
        safe_do(driver, lambda: WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable(
                (By.XPATH, "/html/body/div[2]/div[2]/div[3]/div/div[1]/div[1]/div[1]/ul/li[36]/span[2]"))).click(),
                "点击某个按钮")
        wait_for_block_to_disappear(driver, timeout=80, check_interval=1)
        time.sleep(1)
        update_output_text(output_text, f"{entry_number}结束")
    update_output_text(output_text, "全部完成")


def BBC_House(account, password, output_text):
    expiration_date = expiration_date1
    now = datetime.now()
    func_name = inspect.currentframe().f_code.co_name  # 自动获取当前函数名

    if expiration_date and now > expiration_date:
        if not is_user_allowed(func_name, account):
            update_output_text(output_text, "程序已过期，请联系Larry获取更新版本。\n\n")
            exit()

    user_home = os.path.expanduser("~")
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "BBCreview.xlsx")
        if os.path.exists(file_path):
            update_output_text(output_text, '找到bbcreview，马上运行\n')
            pass
        else:
            wb = Workbook()
            wb.save(file_path)
            update_output_text(output_text, '没能找到bbcreview，已创建，再次点击开始运行代码\n')

            sys.exit()
    else:
        sys.exit()
        update_output_text(output_text, '未能找到bbcreview 且未能创建excel，gg了\n')

    chrome_options = webdriver.ChromeOptions()
    chrome_options.add_argument("--start-maximized")  # 启动时最大化
    chrome_options.add_argument("--disable-gpu")  # 解决某些系统的图形渲染问题
    chrome_options.add_argument("--no-sandbox")  # 非root用户需要此参数
    chrome_options.add_argument("--disable-dev-shm-usage")  # 避免某些共享内存问题
    chrome_options.add_argument("--always-on-top")  # 窗口置顶 (实验性参数)
    chrome_options.add_argument("--force-device-scale-factor=0.5")  # 设置缩放比例为50%

    # 启动 Chrome 浏览器并加载已保存的用户数据
    driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=chrome_options)
    driver.set_window_size(1920, 1080)

    # 通过 JavaScript 强制设置缩放比例
    driver.get("https://www.google.com")
    driver.execute_script("document.body.style.zoom='50%'")
    url = "https://my.acelynknavigator.com/Account/Login.aspx?ReturnUrl=%2fDesktop%2fDefault.aspx"
    driver.get(url)
    driver.maximize_window()  # 最大化窗口

    all_tabs = driver.window_handles
    all_tabs = driver.window_handles

    # 遍历所有窗口，关闭不需要的 "data:" 标签页
    for tab in all_tabs:
        driver.switch_to.window(tab)
        if "data:" in driver.current_url:
            driver.close()  # 关闭 "data:" 标签页

    # 重新获取当前所有窗口句柄
    all_tabs = driver.window_handles

    # 如果有剩余窗口，切换到第一个
    if all_tabs:
        driver.switch_to.window(all_tabs[0])

    try:
        # 等待页面加载并检查是否包含 "sign"
        WebDriverWait(driver, 10).until(
            lambda d: "sign" in d.page_source.lower()  # 等待直到页面包含 "sign"
        )
        print("'sign' found in page source. Continuing...")
    except Exception as e:
        print("Timeout or error while waiting for 'sign':", e)
        driver.quit()
        exit()

    # 输入账号和密码
    username = account  # 替换为实际账号
    password = password  # 替换为实际密码

    # 定位到账号和密码输入框
    username_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_UserName"]')
    username_field.clear()  # 清除输入框中的任何内容
    username_field.send_keys(username)  # 输入用户名

    # 输入密码
    password_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_Password"]')
    password_field.clear()  # 清除输入框中的任何内容
    password_field.send_keys(password)  # 输入密码

    # 点击登录按钮
    login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")  # 替换为实际 ID
    login_button.click()
    print("Current page title is:", driver.title)
    WebDriverWait(driver, 10).until(EC.title_contains("Compliance"))  # 等待页面标题更新为登录后的内容

    try:
        # 定位到登录按钮并点击
        login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")
        login_button.click()

        # 等待检查是否有警告框弹出
        try:
            logout_button = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable((By.XPATH, "//*[@id='lbtLogOutAllSessions']"))
            )
            logout_button.click()
            print("Clicked the logout button in the alert.")

            # 等待页面刷新（可以根据 URL 变化或某个标志性元素来确认）
            WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.ID, "LoginMenu_LoginButton"))  # 确保登录按钮存在
            )
            time.sleep(2)
            username_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_UserName"]')
            username_field.clear()  # 清除输入框中的任何内容
            username_field.send_keys(username)  # 输入用户名

            # 输入密码
            password_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_Password"]')
            password_field.clear()  # 清除输入框中的任何内容
            password_field.send_keys(password)  # 输入密码
            # 重新定位登录按钮
            login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")
            login_button.click()
            print("Clicked the login button.")

        except TimeoutException:
            print("No alert appeared, proceeding with the login.")

        # 等待页面跳转并检查登录后页面标题
        WebDriverWait(driver, 10).until(
            EC.title_contains("Dashboard")  # 这里用登录后的页面标题的一个关键字
        )
        print("Login successful. Page title is:", driver.title)

    except (TimeoutException, NoSuchElementException) as e:
        print(f"Error occurred during login: {e}")
    outputdf = pd.DataFrame(columns=["entry_number", "status_img_src", "pga_img_src", "first_column_data"])
    driver.get("https://my.acelynknavigator.com/Desktop/Default.aspx")
    step_status = True

    def check_alert(driver):
        try:
            time.sleep(1)
            alert = driver.switch_to.alert
            alert_text = alert.text
            print("弹窗内容:", alert_text)

            if "cotton" not in alert_text.lower():
                alert.accept()
                print("已点击确认按钮")
            else:
                alert.dismiss()
                print("检测到 'cotton'，已点击取消按钮")

            time.sleep(1)
        except NoAlertPresentException:
            pass  # 没有弹窗，跳过

    def wait_for_block_to_disappear(driver, timeout=40, check_interval=1):
        """
        等待任何 .blockUI.blockMsg 开头的遮罩层（如 blockElement 或 blockPage）完全消失
        """
        end_time = time.time() + timeout
        while time.time() < end_time:
            try:
                # 查找所有匹配的遮罩层（可能多个）
                elements = driver.find_elements(By.CSS_SELECTOR, "div.blockUI.blockMsg")
                visible_elements = [el for el in elements if el.is_displayed()]

                if visible_elements:
                    print(f"⏳ 检测到 {len(visible_elements)} 个遮罩层，等待中...")
                    time.sleep(check_interval)
                else:
                    print("✅ 所有遮罩层已隐藏")
                    return
            except (NoSuchElementException, StaleElementReferenceException):
                print("✅ 遮罩层不存在或已被移除")
                return
        print("❌ 等待超时，遮罩层仍未消失")

    def open_entry(driver):
        try:
            driver.switch_to.default_content()
            print("✅ 已返回主页面")
        except Exception as e:
            print(f"❌ 返回主页面失败: {e}")

        try:
            # 检查 iframe
            iframes = driver.find_elements(By.TAG_NAME, "iframe")
            print(f"🔎 检测到 {len(iframes)} 个 iframe")
            iframe_switched = False
            if iframes:
                for i, iframe in enumerate(iframes):
                    try:
                        driver.switch_to.frame(iframe)
                        print(f"✅ 切换到 iframe {i}")
                        driver.find_element(By.XPATH,
                                            "(//td[contains(@id, 'EntrySummary')]//ul[@class='nav2']//img)[1]")
                        print("✅ 悬停元素在 iframe 中")
                        iframe_switched = True
                        break
                    except:
                        driver.switch_to.default_content()
                        print(f"❌ iframe {i} 中无目标元素，切换回主页面")
            else:
                print("✅ 无 iframe")

            # 定位悬停元素并提取 <td> 的 id
            img_xpath = "(//td[contains(@id, 'EntrySummary')]//ul[@class='nav2']//img)[1]"
            print(f"🔍 尝试定位悬停元素: {img_xpath}")
            img_elements = driver.find_elements(By.XPATH, img_xpath)
            print(f"🔎 找到 {len(img_elements)} 个悬停元素")
            if len(img_elements) > 1:
                print("⚠️ 警告: 悬停 XPath 匹配到多个元素，可能导致错误")
                for i, elem in enumerate(img_elements):
                    print(f"🔎 悬停元素 {i}: {elem.get_attribute('outerHTML')}")
            img_element = img_elements[0] if img_elements else driver.find_element(By.XPATH, img_xpath)
            print(f"✅ 悬停元素: {img_element.get_attribute('outerHTML')}")

            # 获取父 <td> 的 id
            td_element = img_element.find_element(By.XPATH, "./ancestor::td[contains(@id, 'EntrySummary')]")
            td_id = td_element.get_attribute("id")
            print(f"✅ 找到父 <td> id: {td_id}")

            # 悬停并等待菜单加载
            ActionChains(driver).move_to_element(img_element).perform()
            print("✅ 已执行悬停操作")
            try:
                WebDriverWait(driver, 5).until(
                    EC.presence_of_element_located((By.XPATH, "//a[contains(@class,'shipment-row')]"))
                )
                print("✅ 菜单已加载")
            except TimeoutException:
                print("❌ 菜单未加载，可能悬停失败")

            # 检查弹窗
            def check_alert(driver):
                try:
                    alert = driver.switch_to.alert
                    alert.accept()
                    print("✅ 已关闭弹窗")
                except:
                    print("✅ 无弹窗")

            check_alert(driver)

            # 检查高 z-index 元素
            overlays = driver.find_elements(By.XPATH,
                                            "//*[contains(@style, 'z-index') and not(contains(@style, 'z-index: 0'))]")
            print(f"🔎 检测到 {len(overlays)} 个高 z-index 元素")
            for overlay in overlays[:3]:
                print(f"🔎 覆盖层: {overlay.get_attribute('outerHTML')}")

            # 定位 Edit 按钮，使用父 <td> 的 id 约束
            timeout = 10
            interval = 1
            start_time = time.time()
            edit_xpath = f"//td[@id='{td_id}']//a[contains(@class,'shipment-row') and .//img[contains(@src,'edit_30x30.png')]]"
            print(f"🔍 尝试定位 Edit 按钮: {edit_xpath}")
            edit_elements = driver.find_elements(By.XPATH, edit_xpath)
            print(f"🔎 找到 {len(edit_elements)} 个 Edit 按钮")
            if len(edit_elements) > 1:
                print("⚠️ 警告: Edit XPath 仍匹配到多个元素")
                for i, elem in enumerate(edit_elements):
                    print(f"🔎 Edit 按钮 {i}: {elem.get_attribute('outerHTML')}")
            elif len(edit_elements) == 0:
                print("❌ Edit 按钮未找到，XPath 可能错误或元素未加载")
                print(
                    "🔍 尝试备用 XPath: //a[contains(@class,'shipment-row') and .//img[contains(@src,'edit_30x30.png')]]")
                edit_elements = driver.find_elements(By.XPATH,
                                                     "//a[contains(@class,'shipment-row') and .//img[contains(@src,'edit_30x30.png')]]")
                print(f"🔎 备用 XPath 找到 {len(edit_elements)} 个 Edit 按钮")
                for i, elem in enumerate(edit_elements):
                    print(f"🔎 备用 Edit 按钮 {i}: {elem.get_attribute('outerHTML')}")

            while True:
                try:
                    edit_img = WebDriverWait(driver, interval).until(
                        EC.element_to_be_clickable((By.XPATH, edit_xpath))
                    )
                    print(f"✅ Edit 按钮定位成功: {edit_img.get_attribute('outerHTML')}")
                    print(f"🔎 元素可见: {edit_img.is_displayed()}, 元素可点击: {edit_img.is_enabled()}")
                    try:
                        edit_img.click()
                        print("✅ 点击 Edit 按钮成功")
                        break
                    except ElementClickInterceptedException as e:
                        print(f"❌ 点击被拦截: {e}")
                        print("🔍 尝试 JavaScript 点击")
                        driver.execute_script("arguments[0].click();", edit_img)
                        print("✅ 使用 JavaScript 点击 Edit 按钮")
                        break
                except TimeoutException as e:
                    elapsed = time.time() - start_time
                    print(f"❌ TimeoutException: {e}")
                    if elapsed >= timeout:
                        print("❌ 超过最大等待时间，点击失败")
                        print("📄 当前页面 HTML（部分）:")
                        edit_elements = driver.find_elements(By.XPATH, edit_xpath)
                        if edit_elements:
                            print(f"🔎 Edit 按钮存在但不可点击: {edit_elements[0].get_attribute('outerHTML')}")
                        else:
                            print("🔎 Edit 按钮未在 DOM 中找到")
                        break
                    else:
                        print("❌ 元素未可点，等待1秒后重试...")
                        time.sleep(interval)
                except ElementClickInterceptedException as e:
                    elapsed = time.time() - start_time
                    print(f"❌ ElementClickInterceptedException: {e}")
                    if elapsed >= timeout:
                        print("❌ 超过最大等待时间，点击失败")
                        print("📄 当前页面 HTML（部分）:")
                        edit_elements = driver.find_elements(By.XPATH, edit_xpath)
                        if edit_elements:
                            print(f"🔎 Edit 按钮存在但被遮挡: {edit_elements[0].get_attribute('outerHTML')}")
                        break
                    else:
                        print("❌ 元素被拦截，等待1秒后重试...")
                        time.sleep(interval)

            # 切换回主页面
            if iframe_switched:
                driver.switch_to.default_content()
                print("✅ 切换回主页面")

        except Exception as e:
            print(f"❌ 发生错误: {e}")
            print("📄 当前页面 HTML（部分）:")
            edit_elements = driver.find_elements(By.XPATH, edit_xpath)
            if edit_elements:
                print(f"🔎 Edit 按钮: {edit_elements[0].get_attribute('outerHTML')}")
            else:
                print("🔎 Edit 按钮未找到")

    def search_entry_num(entry_number, timeout=5):
        driver.switch_to.default_content()

        wait_for_block_to_disappear(driver)
        start_time = time.time()
        while True:
            try:

                find_element = WebDriverWait(driver, 10).until(
                    EC.visibility_of_element_located(
                        (By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/button[2]/span[2]"))
                )
                # 模拟鼠标悬停
                actions = ActionChains(driver)
                actions.move_to_element(find_element).perform()
                # 尝试定位并输入 entry_number
                input_box = WebDriverWait(driver, 3).until(
                    EC.visibility_of_element_located((By.XPATH, "//*[@id='advancedSearch']/div/div[8]/input"))
                )
                input_box.clear()
                input_box.send_keys(entry_number)

                # 尝试点击按钮
                search_button = WebDriverWait(driver, 3).until(
                    EC.element_to_be_clickable(
                        (By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/div[3]/div/div[13]/a[1]"))
                )
                search_button.click()

                break  # 成功后跳出循环

            except (ElementNotInteractableException, NoSuchElementException, TimeoutException) as e:
                if time.time() - start_time > timeout:
                    return "超时"
                    break
                else:
                    time.sleep(1)  # 等待1秒后重试

    def safe_do(driver, action, description="", retries=2, retry_delay=0.5):
        """执行一个动作，动作前后都检测并处理 alert，支持失败后自动重试"""
        wait_for_block_to_disappear(driver, timeout=40, check_interval=0.5)
        for attempt in range(retries):
            try:
                check_alert(driver)
                result = action()
                check_alert(driver)
                return result
            except Exception as e:
                print(f"⚠️ {description} 第 {attempt + 1} 次尝试失败: {e}")
                check_alert(driver)
                if attempt < retries - 1:
                    print(f"🔁 准备重试 {description}...")
                    time.sleep(retry_delay)
                else:
                    print(f"❌ {description} 所有尝试失败")
                    return "tryfalse"

    def wait_for_autocomplete(driver, xpath: str, interval: float, duration: float):
        import time
        from selenium.common.exceptions import NoSuchElementException
        from selenium.webdriver.common.by import By

        start_time = time.time()

        while time.time() - start_time < duration:
            try:
                element = driver.find_element(By.XPATH, xpath)
                if element.is_displayed():
                    print("✅ 自动补全栏已弹出")
                    time.sleep(1)
                    return True
            except NoSuchElementException:
                print("🔍 未检测到自动补全栏，继续等待...")

            time.sleep(interval)

        print("❌ 超时未检测到自动补全栏")
        return False

    def data_entry(driver, entry_xpath: str, choose_xpath: str, interval: float, duration: float, content: str):
        try:
            # 清空并输入
            safe_do(driver, lambda: WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.XPATH, entry_xpath))).clear(), "清空输入框")
            safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(""), "输入空内容")
            safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(content), "输入内容")

            # 尝试点击自动补全选项
            import time, re
            start_time = time.time()

            # 提取 ul 的索引
            ul_pattern = re.search(r'ul\[(\d+)\]', choose_xpath)
            if not ul_pattern:
                print("❌ choose_xpath 无法识别 ul[x] 的格式")
                return

            base_index = int(ul_pattern.group(1))
            prefix, suffix = choose_xpath.split(f'ul[{base_index}]')

            while time.time() - start_time < duration:
                for i in range(11):  # 最多尝试 base 到 base+10
                    trial_xpath = f"{prefix}ul[{base_index + i}]{suffix}"
                    print(f"尝试点击: {trial_xpath}")
                    result = safe_do(driver, lambda: WebDriverWait(driver, interval).until(
                        EC.element_to_be_clickable((By.XPATH, trial_xpath))).click(),
                                     f"点击自动补全项 ul[{base_index + i}]")

                    if result != "tryfalse":
                        print(f"✅ 点击成功: {trial_xpath}")
                        return

            print("❌ 所有自动补全尝试失败")

        except Exception as e:
            print("❌ data_entry 函数发生异常：", e)
            check_alert(driver)

    def file_edit(file_path, results_dict):
        wb = openpyxl.load_workbook(file_path)
        ws = wb.active

        def find_first_empty_row_from_col(ws, start_col=5):
            max_check_rows = ws.max_row + 100  # 最多检查100行
            for row in range(1, max_check_rows):
                if all(ws.cell(row=row, column=col).value in [None, ""] for col in range(start_col, start_col + 20)):
                    return row
            return ws.max_row + 1

        current_row = find_first_empty_row_from_col(ws, start_col=5)

        for entry_list in results_dict.values():
            for entry in entry_list:
                # 第5列 line 字段清洗 → 提取 of 后数字
                raw_line = entry.get("line", "")
                match = re.search(r"of\s+(\d+)", raw_line)
                entry["line"] = match.group(1) if match else raw_line  # 保留数字

                # 第8列 port1 字段清洗 → 提取最后数字
                raw_port1 = entry.get("port1", "")
                if "-" in raw_port1:
                    entry["port1"] = raw_port1.split("-")[-1].strip()
                else:
                    entry["port1"] = raw_port1

                # 写入清洗后的值，从第5列开始写
                values = list(entry.values())
                for i, value in enumerate(values):
                    ws.cell(row=current_row, column=5 + i, value=value)
                current_row += 1

        wb.save(file_path)

    def normal_entry(driver, entry_xpath: str, interval: float, duration: float, content: str):

        try:
            safe_do(driver, lambda: WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.XPATH, entry_xpath))).clear(), "清空输入框")
            safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(""), "输入空内容")
            safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(content), "输入内容")

        except Exception as e:
            # 这里捕获其他异常并打印详细信息
            print("❌ 发生其他异常：", e)

    results_dict = {}

    def page_viewd(driver, house):
        result = []
        data_dict = {}
        try:
            try:
                iframe = driver.find_element(By.ID, "iframeInvoices")
                driver.switch_to.frame(iframe)
            except:
                pass
            success = wait_for_autocomplete(driver,
                                            "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[2]/div[2]/fieldset/div[3]/div/div[4]/form/div/fieldset[3]/div/div/a[2]",
                                            0.5, 8.0)

            if success:
                line_xpath = "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[2]/div[2]/form/div/div/fieldset/div/div/div[2]/div[2]/div[1]"
                importer_xpath = "/html/body/form/div[3]/div[2]/div[1]/div/fieldset/div[1]/input"
                qty_xpath = "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[2]/div[2]/fieldset/div[3]/div/div[4]/form/div/fieldset[3]/div/div/div[2]/div[2]/div[4]/input"
                port1_xpath = "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[2]/div[2]/fieldset/div[3]/div/div[4]/form/div/div[3]/div[4]/input"
                port2_xpath = "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[2]/div[2]/fieldset/div[3]/div/div[4]/form/div/div[3]/div[16]/input"
                paytype_xpath = "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[2]/div[2]/fieldset/div[3]/div/div[4]/form/div/div[3]/div[16]/input"
                remote_xpath = "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[2]/div[2]/fieldset/div[3]/div/div[4]/form/div/fieldset[2]/div/div/div/table/tbody/tr[2]/td[1]/div/input"
                house_xpath = "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[2]/div[2]/fieldset/div[3]/div/div[4]/form/div/fieldset[3]/div/div/div[2]/div[3]/div[3]/input"
                statementdate_xpath = "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[2]/div[2]/fieldset/div[3]/div/div[4]/form/div/div[4]/div[8]/input"
                try:
                    data_dict['line'] = driver.find_element(By.XPATH, line_xpath).text.strip()
                except:
                    data_dict['line'] = ""

                try:
                    data_dict['importer'] = driver.find_element(By.XPATH, importer_xpath).get_attribute("value").strip()
                except:
                    data_dict['importer'] = ""

                try:
                    data_dict['qty'] = driver.find_element(By.XPATH, qty_xpath).get_attribute("value").strip()
                except:
                    data_dict['qty'] = ""

                try:
                    data_dict['port1'] = driver.find_element(By.XPATH, port1_xpath).get_attribute("value").strip()
                except:
                    data_dict['port1'] = ""

                try:
                    data_dict['port2'] = driver.find_element(By.XPATH, port2_xpath).get_attribute("value").strip()
                except:
                    data_dict['port2'] = ""

                try:
                    data_dict['paytype'] = driver.find_element(By.XPATH, paytype_xpath).get_attribute("value").strip()
                except:
                    data_dict['paytype'] = ""

                try:
                    checkbox_element = driver.find_element(By.XPATH, remote_xpath)
                    data_dict['remote_checked'] = checkbox_element.is_selected()
                except:
                    data_dict['remote_checked'] = False

                try:
                    data_dict['house'] = driver.find_element(By.XPATH, house_xpath).get_attribute("value").strip()
                except:
                    data_dict['house'] = ""

                try:
                    data_dict['statementdate'] = driver.find_element(By.XPATH, statementdate_xpath).get_attribute(
                        "value").strip()
                except:
                    data_dict['statementdate'] = ""

                # 把字典放进列表
                result.append(data_dict)

                click_xpath = "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[2]/div[2]/fieldset/div[3]/div/div[4]/form/div/fieldset[3]/div/div/a[2]"
                btn = driver.find_element(By.XPATH, click_xpath)
                btn.click()

                # 提取 SCAC, QTR, UOM 的三个输入框内容
                scac_xpath = "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[2]/div[2]/fieldset/div[3]/div/div[4]/form/div/fieldset[3]/div/div/div[2]/div[2]/div[2]/input"
                qtr_xpath = "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[2]/div[2]/fieldset/div[3]/div/div[4]/form/div/fieldset[3]/div/div/div[2]/div[2]/div[4]/input"
                uom_xpath = "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[2]/div[2]/fieldset/div[3]/div/div[4]/form/div/fieldset[3]/div/div/div[2]/div[2]/div[5]/input"

                scac = driver.find_element(By.XPATH, scac_xpath).get_attribute('value')
                qtr = driver.find_element(By.XPATH, qtr_xpath).get_attribute('value')
                uom = driver.find_element(By.XPATH, uom_xpath).get_attribute('value')

                # 用三个值填入表单
                input_1_xpath = "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[2]/div[2]/fieldset/div[3]/div/div[4]/form/div/fieldset[3]/div/div/div[2]/div[3]/div[2]/input"
                input_2_xpath = "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[2]/div[2]/fieldset/div[3]/div/div[4]/form/div/fieldset[3]/div/div/div[2]/div[3]/div[3]/input"
                input_3_xpath = "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[2]/div[2]/fieldset/div[3]/div/div[4]/form/div/fieldset[3]/div/div/div[2]/div[3]/div[4]/input"
                input_4_xpath = "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[2]/div[2]/fieldset/div[3]/div/div[4]/form/div/fieldset[3]/div/div/div[2]/div[3]/div[5]/input"
                data_entry(driver, input_1_xpath, "/html/body/ul[24]/li[1]/div", 0.5, 8.0, scac)

                normal_entry(driver, input_2_xpath, 0.5, 8.0, house)
                normal_entry(driver, input_3_xpath, 0.5, 8.0, qtr)
                data_entry(driver, input_4_xpath, "/html/body/ul[25]/li[1]/div", 0.5, 8.0, uom)
                return result

            else:
                return None
                print("元素未加载成功，跳过处理。")

        except Exception as e:
            return None
            print("发生异常:", e)

    file_path = os.path.join(desktop_path, "BBCreview.xlsx")
    file_path = file_path
    df = pd.read_excel(file_path, header=None, dtype=str)  # 加 dtype=str 读进来就全是字符串

    # 通过 iloc 访问第一列（假设是 A 列）
    a_column = df.iloc[:, 0]  # 选择第一列
    c_column = df.iloc[:, 2]  # 选择第一列

    # 过滤掉 'na' 和 NaN 值
    filtered_lista = a_column[a_column.notna() & (a_column != 'na')].tolist()
    filtered_listc = c_column[c_column.notna() & (c_column != 'na')].tolist()
    print(filtered_listc)

    results_dict = {}
    wait_for_block_to_disappear(driver, timeout=600, check_interval=1)
    # open_entry(driver)
    # wait_for_block_to_disappear(driver, timeout=600, check_interval=1)

    for entry_number, house in zip(filtered_lista, filtered_listc):
        update_output_text(output_text, f"正在处理{entry_number}\n")
        search_entry_num(entry_number, timeout=5)
        wait_for_block_to_disappear(driver, timeout=600, check_interval=1)
        check_alert(driver)
        open_entry(driver)
        safe_do(driver, lambda: WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable(
                (By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/div[3]/div/div[13]/a[2]"))).click(),
                "点击某个按钮")
        info_text = page_viewd(driver, house)
        results_dict[entry_number] = info_text
        safe_do(driver, lambda: WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.XPATH,
                                        "//html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[1]/div[1]/span[2]/ul/li[1]/a"))).click(),
                "点击某个按钮")
        safe_do(driver, lambda: WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable((By.XPATH,
                                        "//html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[1]/div[1]/span[2]/ul/li[1]/a"))).click(),
                "点击某个按钮")
        wait_for_block_to_disappear(driver, timeout=600, check_interval=1)
        update_output_text(output_text, f"处理已完成{entry_number}\n")
        try:
            driver.switch_to.default_content()
            print("成功切换回来")
        except Exception as e:
            print(f"⚠️ 切换回主页面失败: {e}")
            pass
        safe_do(driver, lambda: WebDriverWait(driver, 10).until(
            EC.element_to_be_clickable(
                (By.XPATH, "/html/body/div[2]/div[2]/div[3]/div/div[1]/div[1]/div[1]/ul/li[36]/span[2]"))).click(),
                "点击某个按钮")
        wait_for_block_to_disappear(driver, timeout=80, check_interval=1)
        time.sleep(1)

        wait_for_block_to_disappear(driver, timeout=600, check_interval=1)
        time.sleep(1)

    file_edit(file_path, results_dict)
    update_output_text(output_text, "文件已保存\n")


def BBC_review_program(account, password, output_text):
    from seleniumwire import webdriver
    expiration_date = expiration_date1
    now = datetime.now()
    func_name = inspect.currentframe().f_code.co_name  # 自动获取当前函数名

    if expiration_date and now > expiration_date:
        if not is_user_allowed(func_name, account):
            update_output_text(output_text, "程序已过期，请联系Larry获取更新版本。\n\n")
            exit()
    data_dict = {}

    user_home = os.path.expanduser("~")
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "BBCreview.xlsx")
        if os.path.exists(file_path):
            update_output_text(output_text, "已找到BBCreview\n")
            pass
        else:
            # 创建空的 Excel 文件
            wb = Workbook()
            wb.save(file_path)
            update_output_text(output_text, "已创建BBCreview，再次运行即可开始代码\n")
            sys.exit()  # 程序立即停止
    else:
        update_output_text(output_text, "创建excel失败，请联系larry解决\n")
        sys.exit()  # 程序立即停止

    # 固定路径：AppData\Local
    fixed_path = os.path.join(user_home, "AppData", "Local")
    txt_file_path = os.path.join(fixed_path, "origincode.txt")

    if not os.path.exists(txt_file_path):
        try:
            with open(txt_file_path, 'w', encoding='utf-8') as f:
                pass  # 创建空文件
            update_output_text(output_text, '已匹配至larry本地服务器, 请再点击一次运行以运行\n')
            sys.exit()
        except Exception as e:
            update_output_text(output_text, '连接失败，请联系larry解决\n')
            sys.exit()
    else:
        update_output_text(output_text, '正在像larry服务器传送内容，开始代码\n')
        time.sleep(5)
        update_output_text(output_text, '已连接larry本地服务器，开始代码\n')

    chrome_options = webdriver.ChromeOptions()
    chrome_options.add_argument("--start-maximized")  # 启动时最大化
    chrome_options.add_argument("--disable-gpu")  # 解决某些系统的图形渲染问题
    chrome_options.add_argument("--no-sandbox")  # 非root用户需要此参数
    chrome_options.add_argument("--disable-dev-shm-usage")  # 避免某些共享内存问题
    chrome_options.add_argument("--always-on-top")  # 窗口置顶 (实验性参数)
    chrome_options.add_argument("--force-device-scale-factor=0.5")  # 设置缩放比例为50%

    # 启动 Chrome 浏览器并加载已保存的用户数据
    driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=chrome_options)
    driver.set_window_size(1920, 1080)

    # 通过 JavaScript 强制设置缩放比例
    driver.get("https://www.google.com")
    driver.execute_script("document.body.style.zoom='50%'")
    url = "https://my.acelynknavigator.com/Account/Login.aspx?ReturnUrl=%2fDesktop%2fDefault.aspx"
    driver.get(url)
    driver.maximize_window()  # 最大化窗口

    all_tabs = driver.window_handles
    all_tabs = driver.window_handles

    # 遍历所有窗口，关闭不需要的 "data:" 标签页
    for tab in all_tabs:
        driver.switch_to.window(tab)
        if "data:" in driver.current_url:
            driver.close()  # 关闭 "data:" 标签页

    # 重新获取当前所有窗口句柄
    all_tabs = driver.window_handles

    # 如果有剩余窗口，切换到第一个
    if all_tabs:
        driver.switch_to.window(all_tabs[0])

    try:
        # 等待页面加载并检查是否包含 "sign"
        WebDriverWait(driver, 10).until(
            lambda d: "sign" in d.page_source.lower()  # 等待直到页面包含 "sign"
        )
        print("'sign' found in page source. Continuing...")
    except Exception as e:
        print("Timeout or error while waiting for 'sign':", e)
        driver.quit()
        exit()

    # 输入账号和密码
    username = account  # 替换为实际账号
    password = password  # 替换为实际密码

    # 定位到账号和密码输入框
    username_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_UserName"]')
    username_field.clear()  # 清除输入框中的任何内容
    username_field.send_keys(username)  # 输入用户名

    # 输入密码
    password_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_Password"]')
    password_field.clear()  # 清除输入框中的任何内容
    password_field.send_keys(password)  # 输入密码

    # 点击登录按钮
    login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")  # 替换为实际 ID
    login_button.click()
    print("Current page title is:", driver.title)
    WebDriverWait(driver, 10).until(EC.title_contains("Compliance"))  # 等待页面标题更新为登录后的内容

    try:
        # 定位到登录按钮并点击
        login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")
        login_button.click()

        # 等待检查是否有警告框弹出
        try:
            logout_button = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable((By.XPATH, "//*[@id='lbtLogOutAllSessions']"))
            )
            logout_button.click()
            print("Clicked the logout button in the alert.")

            # 等待页面刷新（可以根据 URL 变化或某个标志性元素来确认）
            WebDriverWait(driver, 10).until(
                EC.presence_of_element_located((By.ID, "LoginMenu_LoginButton"))  # 确保登录按钮存在
            )
            time.sleep(2)
            username_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_UserName"]')
            username_field.clear()  # 清除输入框中的任何内容
            username_field.send_keys(username)  # 输入用户名

            # 输入密码
            password_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_Password"]')
            password_field.clear()  # 清除输入框中的任何内容
            password_field.send_keys(password)  # 输入密码
            # 重新定位登录按钮
            login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")
            login_button.click()
            print("Clicked the login button.")

        except TimeoutException:
            print("No alert appeared, proceeding with the login.")

        # 等待页面跳转并检查登录后页面标题
        WebDriverWait(driver, 10).until(
            EC.title_contains("Dashboard")  # 这里用登录后的页面标题的一个关键字
        )
        print("Login successful. Page title is:", driver.title)

    except (TimeoutException, NoSuchElementException) as e:
        print(f"Error occurred during login: {e}")


    def get_cookies_from_selenium(driver):
        cookies = driver.get_cookies()
        # 把 selenium 的 cookie 转成 requests 能用的格式
        cookie_dict = {c['name']: c['value'] for c in cookies}
        return "; ".join([f"{k}={v}" for k, v in cookie_dict.items()])

    def status_api(entry_number, cookie_str):
        url = "https://my.acelynknavigator.com/Desktop/Default.aspx/GetImporterShipments"
        headers = {
            "Content-Type": "application/json; charset=UTF-8",
            "X-Requested-With": "XMLHttpRequest",
            "Origin": "https://my.acelynknavigator.com",
            "Referer": "https://my.acelynknavigator.com/",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36",
            "Cookie": cookie_str,
        }
        payload = {
            "id": "0",
            "startDate": "",
            "endDate": "",
            "brokerRef": "",
            "importerRef": "",
            "bol": "",
            "invoiceNumber": "",
            "container": "",
            "entryNumber": str(entry_number),
            "partialSearch": True,
            "releasePort": "",
            "userName": "",
            "vesselName": ""
        }
        session = requests.Session()
        retries = Retry(total=3, backoff_factor=1, status_forcelist=[502, 503, 504])
        session.mount('https://', HTTPAdapter(max_retries=retries))

        try:
            response = session.post(url, headers=headers, data=json.dumps(payload), timeout=30)
            print(response.status_code)
            response = response.text
            return response
        except (ConnectionError, Timeout, RequestException) as e:
            print(f"请求失败: {e}")
            return None

    def get_entrystatus(response):
        try:
            data_outer = json.loads(response)

            # 解析内层的字符串为列表
            data_list = json.loads(data_outer['d'])

            # 取第一个字典
            item = data_list[0]

            def extract_or_error(key):
                val = item.get(key)
                if val is None:
                    return "N/A"
                return val

            def extract_img_filename_or_null(html_str):
                if not html_str or html_str == "N/A":
                    return None
                m = re.search(r'/images/icons/([^"]+\.png)', html_str)
                if m:
                    return m.group(1)
                return None

            InvoiceNumber = extract_or_error("InvoiceNumber")
            EntryNumber = extract_or_error("EntryNumber")
            StatusOverride3461 = extract_img_filename_or_null(extract_or_error("CargoReleaseStatusFlag")) or "N/A"
            EntrySummaryStatusFlag = extract_img_filename_or_null(extract_or_error("EntrySummaryStatusFlag")) or "N/A"
            BillStatusFlag = extract_img_filename_or_null(extract_or_error("BillStatusFlag")) or "N/A"
            PGA = extract_or_error("PGA")
            EntrySummaryId = extract_or_error("EntrySummaryId")

            print(InvoiceNumber)
            print(EntryNumber)
            print(StatusOverride3461)
            print(EntrySummaryStatusFlag)
            print(BillStatusFlag)
            print(PGA)
            print(EntrySummaryId)

            return InvoiceNumber, EntryNumber, StatusOverride3461, EntrySummaryStatusFlag, BillStatusFlag, PGA, EntrySummaryId


        except:
            return None, None, None, None, None, None, None

    GREEN = PatternFill(start_color="00C6EFCE", end_color="00C6EFCE", fill_type="solid")
    YELLOW = PatternFill(start_color="00FFEB9C", end_color="00FFEB9C", fill_type="solid")
    RED = PatternFill(start_color="00FFC7CE", end_color="00FFC7CE", fill_type="solid")
    GRAY = PatternFill(start_color="00D9D9D9", end_color="00D9D9D9", fill_type="solid")
    PURPLE = PatternFill(start_color="00B4A7D6", end_color="00B4A7D6", fill_type="solid")

    # 主流程
    wb = openpyxl.load_workbook(file_path)
    ws = wb.active
    # 从第1行开始读取（包括表头）
    first_column_values = [ws.cell(row=row, column=1).value for row in range(1, ws.max_row + 1)]
    update_output_text(output_text, f"所有要处理的entry:{first_column_values}\n")
    print(f"First column values: {first_column_values}")

    # 获取 cookie（移到循环外，避免重复调用）
    cookie_str = get_cookies_from_selenium(driver)
    print(f"Cookie string: {cookie_str}")

    # 遍历第一列
    for row_index, entry in enumerate(first_column_values, start=1):
        if not entry:
            print(f"Skipping row {row_index}: empty entry")
            continue

        # 如果是表头行，特殊处理（可选）
        if row_index == 1 and "entry" in str(entry).lower():  # 假设表头包含 "entry"
            print(f"Skipping header row: {entry}")
            continue

        # 调用接口
        raw_status = status_api(entry, cookie_str)
        print(f"Row {row_index}: entry = {entry}, raw_status = {raw_status}")

        # 解析数据
        values = get_entrystatus(raw_status)
        print(f"Row {row_index}: values = {values}")

        # 写入 3-9 列
        for col, val in enumerate(values, start=3):
            print(f"Writing to row {row_index}, column {col}: {val}")
            ws.cell(row=row_index, column=col, value=val)

    # 写入第 10 列和第 11 列
    for row_index in range(1, ws.max_row + 1):
        col6_val = str(ws.cell(row=row_index, column=6).value).lower()
        col7_val = str(ws.cell(row=row_index, column=7).value).lower()

        col8_val = str(ws.cell(row=row_index, column=8).value).lower()
        print(f"Row {row_index}: col6_val = {col6_val}, col8_val = {col8_val}")
        if "red" in col7_val:
            ws.cell(row=row_index, column=7).fill = RED
        # 第10列
        if "green" in col6_val:
            ws.cell(row=row_index, column=10, value="RELEASED").fill = GREEN
        else:
            if "yellow" in col6_val:
                color = YELLOW
            elif "red" in col6_val:
                color = RED
            elif "white" in col6_val:
                color = GRAY
            else:
                color = PURPLE
            ws.cell(row=row_index, column=10, value="AI SUBMIT").fill = color

        # 第11列
        if "accepted" in col8_val:
            ws.cell(row=row_index, column=11, value="MAY PROCEED").fill = GREEN
        elif "n/a" in col8_val or "new" in col8_val:
            ws.cell(row=row_index, column=11, value="MAY PROCEED").fill = GREEN
        elif "pending" in col8_val:
            ws.cell(row=row_index, column=11, value="CPSC REVIEW").fill = YELLOW
        else:
            ws.cell(row=row_index, column=11, value="ISSUE").fill = RED

    # 保存文件
    wb.save(file_path)
    wb.close()
    update_output_text(output_text, "代码完成\n\n")



def transmit_program(account, password, output_text):
    expiration_date = expiration_date1
    now = datetime.now()
    func_name = inspect.currentframe().f_code.co_name  # 自动获取当前函数名

    if expiration_date and now > expiration_date:
        if not is_user_allowed(func_name, account):
            update_output_text(output_text, "程序已过期，请联系Larry获取更新版本。\n\n")
            exit()

    # 获取用户主目录
    user_home = os.path.expanduser("~")

    # 检测可能的桌面路径
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    # 查找存在的桌面路径
    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "extract.xlsx")
        if os.path.exists(file_path):
            update_output_text(output_text, f"找到文件：{file_path}\n\n")
        else:
            # 创建空的 Excel 文件
            wb = Workbook()
            wb.save(file_path)
            update_output_text(output_text, f"未找到文件，已创建新文件：{file_path}\n\n")
            sys.exit()  # 程序立即停止
    else:
        update_output_text(output_text, "未找到有效的桌面路径\n")
        sys.exit()  # 程序立即停止

    # 读取 Excel 文件
    df = pd.read_excel(file_path, header=None, dtype=str)  # 如果没有列名，使用 header=None

    # 通过 iloc 访问第一列（假设是 A 列）
    a_column = df.iloc[:, 0]  # 选择第一列

    # 过滤掉 'na' 和 NaN 值
    filtered_list = a_column[a_column.notna() & (a_column != 'na')].tolist()
    update_output_text(output_text, f"所有需要处理的inbond: {filtered_list}\n")

    try:
        # 配置 ChromeOptions
        options = webdriver.ChromeOptions()
        chrome_binary = r"C:\Program Files\Google\Chrome\Application\chrome.exe"
        options.binary_location = chrome_binary
        options.add_argument("--no-sandbox")
        options.add_argument("--disable-dev-shm-usage")

        # 检查 Chrome 可执行文件是否存在
        if os.path.exists(chrome_binary):
            update_output_text(output_text, f"Chrome 可执行文件存在: {chrome_binary}\n")
        else:
            update_output_text(output_text, f"Chrome 可执行文件不存在: {chrome_binary}\n")
            raise FileNotFoundError(f"Chrome 可执行文件未找到: {chrome_binary}")

        # 获取 ChromeDriver 路径和版本
        try:
            driver_path = ChromeDriverManager().install()
            update_output_text(output_text, f"ChromeDriver 路径: {driver_path}\n")
            # 检查 ChromeDriver 版本
            driver_version = subprocess.check_output([driver_path, "--version"]).decode().strip()
            update_output_text(output_text, f"ChromeDriver 版本: {driver_version}\n")
        except Exception as e:
            update_output_text(output_text, f"获取 ChromeDriver 路径或版本失败: {str(e)}\n")
            raise

        # 检查系统 PATH
        system_path = os.environ.get("PATH", "")
        update_output_text(output_text, f"系统 PATH: {system_path}\n")

        # 初始化 Chrome 浏览器
        update_output_text(output_text, "开始初始化 ChromeDriver...\n")
        driver = webdriver.Chrome(service=Service(driver_path), options=options)
        update_output_text(output_text, "ChromeDriver 初始化成功\n")

    except webdriver.WebDriverException as wde:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (WebDriverException): {str(wde)}\n")
        update_output_text(output_text, f"堆栈跟踪: {traceback.format_exc()}\n")
        raise
    except FileNotFoundError as fnfe:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (FileNotFoundError): {str(fnfe)}\n")
        raise
    except Exception as e:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (未知错误): {str(e)}\n")
        update_output_text(output_text, f"堆栈跟踪: {traceback.format_exc()}\n")
        raise
    url = "https://www.netchb.com/app/home.do"
    driver.get(url)

    WebDriverWait(driver, 20).until(
        EC.presence_of_element_located((By.XPATH, '//*[@id="lName"]'))
    ).send_keys(account)

    # 等待 Password 输入框出现并输入密码
    WebDriverWait(driver, 20).until(
        EC.presence_of_element_located((By.XPATH, '//*[@id="pass"]'))
    ).send_keys(password)

    xpath = '//*[@id="loginForm"]/div[2]/input'
    login_button = driver.find_element(By.XPATH, xpath)
    login_button.click()
    target_url = f"https://www.netchb.com/app/inbond/inbondMenu.do?itNo={'054294590'}"
    # 打开页面
    driver.get(target_url)
    # 遍历 filtered_list 中的每个项目
    for item in filtered_list:
        if windowname != "task":
            print("窗口已关闭，程序终止。")  # 调试打印
            update_output_text(output_text, "窗口已关闭，程序终止。\n")
            sys.exit()  # 窗口已关闭，退出程序
        target_url = f"https://www.netchb.com/app/inbond/inbondMenu.do?itNo={item}"
        # 打开页面
        driver.get(target_url)

        current_title = driver.title
        update_output_text(output_text, f"正在处理{item}\n")

        try:
            # 查找特定的元素，增加最长等待时间
            element_xpath = '/html/body/table/tbody/tr[2]/td[2]/table[5]/tbody/tr[1]/td[2]/input'

            # 等待最多 50 秒，直到元素可点击
            element = WebDriverWait(driver, 50).until(
                EC.element_to_be_clickable((By.XPATH, element_xpath))
            )

            # 如果元素存在并且可点击，点击它
            element.click()

        except Exception as e:
            # 如果元素未找到或不可点击，打印消息
            update_output_text(output_text, f"没有找到元素 {item} 的按钮！错误: {e}\n")

    # 等待用户输入后关闭浏览器
    input("按 Enter 键关闭浏览器...")
    driver.quit()


def hold_program(account, password, output_text, inputnum):
    global windowname
    expiration_date = expiration_date1
    now = datetime.now()
    func_name = inspect.currentframe().f_code.co_name  # 自动获取当前函数名

    if expiration_date and now > expiration_date:
        if not is_user_allowed(func_name, account):
            update_output_text(output_text, "程序已过期，请联系Larry获取更新版本。\n\n")
            exit()

    # 获取用户主目录
    user_home = os.path.expanduser("~")

    # 检测可能的桌面路径
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    # 查找存在的桌面路径
    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "找hold.xlsx")
        if os.path.exists(file_path):
            update_output_text(output_text, f"找到文件：{file_path}\n")
        else:
            # 创建空的 Excel 文件
            wb = Workbook()
            wb.save(file_path)
            update_output_text(output_text, f"未找到文件，已创建新文件：{file_path}\n")
            sys.exit()  # 程序立即停止
    else:
        update_output_text(output_text, "未找到有效的桌面路径\n")
        sys.exit()  # 程序立即停止

    # 读取 Excel 文件
    df = pd.read_excel(file_path, header=None, dtype=str)  # 如果没有列名，使用 header=None

    # 通过 iloc 访问第一列（假设是 A 列）
    a_column = df.iloc[:, 0]  # 选择第一列
    c_column = df.iloc[:, 2]  # 选择第一列

    # 过滤掉 'na' 和 NaN 值
    filtered_list = a_column[a_column.notna() & (a_column != 'na')].tolist()

    filtered_listc = c_column.dropna().apply(
        lambda x: int(x) if isinstance(x, (int, float)) and x == int(x) else x).tolist()

    # 打印结果
    update_output_text(output_text, filtered_list)
    update_output_text(output_text, "\n\n")  # 添加两个换行符
    update_output_text(output_text, filtered_listc)
    try:
        # 配置 ChromeOptions
        options = webdriver.ChromeOptions()
        chrome_binary = r"C:\Program Files\Google\Chrome\Application\chrome.exe"
        options.binary_location = chrome_binary
        options.add_argument("--no-sandbox")
        options.add_argument("--disable-dev-shm-usage")

        # 检查 Chrome 可执行文件是否存在
        if os.path.exists(chrome_binary):
            update_output_text(output_text, f"Chrome 可执行文件存在: {chrome_binary}\n")
        else:
            update_output_text(output_text, f"Chrome 可执行文件不存在: {chrome_binary}\n")
            raise FileNotFoundError(f"Chrome 可执行文件未找到: {chrome_binary}")

        # 获取 ChromeDriver 路径和版本
        try:
            driver_path = ChromeDriverManager().install()
            update_output_text(output_text, f"ChromeDriver 路径: {driver_path}\n")
            # 检查 ChromeDriver 版本
            driver_version = subprocess.check_output([driver_path, "--version"]).decode().strip()
            update_output_text(output_text, f"ChromeDriver 版本: {driver_version}\n")
        except Exception as e:
            update_output_text(output_text, f"获取 ChromeDriver 路径或版本失败: {str(e)}\n")
            raise

        # 检查系统 PATH
        system_path = os.environ.get("PATH", "")
        update_output_text(output_text, f"系统 PATH: {system_path}\n")

        # 初始化 Chrome 浏览器
        update_output_text(output_text, "开始初始化 ChromeDriver...\n")
        driver = webdriver.Chrome(service=Service(driver_path), options=options)
        update_output_text(output_text, "ChromeDriver 初始化成功\n")

    except webdriver.WebDriverException as wde:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (WebDriverException): {str(wde)}\n")
        update_output_text(output_text, f"堆栈跟踪: {traceback.format_exc()}\n")
        raise
    except FileNotFoundError as fnfe:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (FileNotFoundError): {str(fnfe)}\n")
        raise
    except Exception as e:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (未知错误): {str(e)}\n")
        update_output_text(output_text, f"堆栈跟踪: {traceback.format_exc()}\n")
        raise
    url = "https://www.netchb.com/app/home.do"
    driver.get(url)
    WebDriverWait(driver, 20).until(
        EC.presence_of_element_located((By.XPATH, '//*[@id="lName"]'))
    ).send_keys(account)

    # 等待 Password 输入框出现并输入密码
    WebDriverWait(driver, 20).until(
        EC.presence_of_element_located((By.XPATH, '//*[@id="pass"]'))
    ).send_keys(password)

    xpath = '//*[@id="loginForm"]/div[2]/input'
    login_button = driver.find_element(By.XPATH, xpath)
    login_button.click()
    target_url = "https://www.netchb.com/app/inbond/inbondMenu.do?itNo=862326905"
    driver.get(target_url)

    current_title = driver.title
    current_frame = tk.Frame(root)
    current_frame.pack()
    print(windowname)
    if inputnum == "仅查找":
        for itNo in filtered_list:
            # 调试打印
            if windowname != "task":
                print("窗口已关闭，程序终止。")  # 调试打印
                update_output_text(output_text, "窗口已关闭，程序终止。\n")
                sys.exit()  # 窗口已关闭，退出程序

            target_url = f"https://www.netchb.com/app/inbond/inbondMenu.do?itNo={itNo}"
            driver.get(target_url)

            try:
                # 等待表格加载
                wait = WebDriverWait(driver, 10)
                table_body = wait.until(
                    EC.presence_of_element_located((By.XPATH, '//*[@id="manifestBody"]'))
                )

                for b_element in filtered_listc:
                    # if (itNo, b_element) in found_records:
                    #     continue  # 跳过已找到的 filterb

                    try:
                        # 查找包含 b_element 的元素
                        record_element = table_body.find_element(By.XPATH, f".//*[contains(text(), '{b_element}')]")

                        update_output_text(output_text, f"找到匹配项: {itNo} - {b_element}")

                    except NoSuchElementException:
                        continue  # 未找到 b_element，继续找下一个

            except Exception as e:
                update_output_text(output_text, f"错误发生在 {itNo}: {e}")
        time.sleep(0.5)
        update_output_text(output_text, f"匹配结果: {000}")
    if inputnum == "删除":

        found_records = []
        for itNo in filtered_list:
            if windowname != "task":
                update_output_text(output_text, "窗口已关闭，程序终止。\n")
                sys.exit()  # 窗口已关闭，退出程序

            target_url = f"https://www.netchb.com/app/inbond/inbondMenu.do?itNo={itNo}"
            driver.get(target_url)

            try:
                # 等待表格加载
                wait = WebDriverWait(driver, 10)
                table_body = wait.until(
                    EC.presence_of_element_located((By.XPATH, '//*[@id="manifestBody"]'))
                )

                rows = table_body.find_elements(By.XPATH, ".//tr")  # 获取所有行

                for b_element in filtered_listc:
                    # if (itNo, b_element) in found_records:
                    #     continue  # 跳过已找到的 filterb

                    try:
                        record_element = table_body.find_element(By.XPATH, f".//*[contains(text(), '{b_element}')]")
                    except NoSuchElementException:
                        continue  # 没找到直接跳过

                    b_element_str = str(b_element)  # 转换 b_element 为字符串
                    found_in_row = False  # 标记是否找到匹配项

                    for idx, row in enumerate(rows, start=1):
                        cell_elements = row.find_elements(By.XPATH, ".//td")
                        for cell in cell_elements:
                            if b_element_str in str(cell.text):  # 强制转换 cell.text 进行匹配
                                found_records.append((itNo, b_element))  # 记录已找到

                                delete_button_xpath = f'/html/body/table/tbody/tr[2]/td[2]/table[3]/tbody/tr/td[1]/table[2]/tbody/tr[{idx}]/td[5]/input'
                                abutton_xpath = f'/html/body/table/tbody/tr[2]/td[2]/table[3]/tbody/tr/td[1]/table[2]/tbody/tr[{idx}]/td[2]'

                                try:
                                    delete_button = WebDriverWait(driver, 5).until(
                                        EC.element_to_be_clickable((By.XPATH, delete_button_xpath))
                                    )

                                except Exception as e:
                                    continue  # 如果找不到 delete_button，则跳过当前行

                                try:
                                    button_element = driver.find_element(By.XPATH, abutton_xpath)
                                    update_output_text(output_text, f"{itNo}中的{button_element.text}")


                                except NoSuchElementException:
                                    continue  # 如果找不到 abutton，则跳过当前行

                                delete_button.click()
                                time.sleep(0.5)

                                try:
                                    alert = driver.switch_to.alert  # 获取当前弹窗
                                    alert.accept()  # 点击确认按钮
                                    time.sleep(0.5)
                                    update_output_text(output_text, "成功删除")
                                except NoAlertPresentException:
                                    pass

                                # 删除后重新获取 table_body 和 rows
                                table_body = wait.until(
                                    EC.presence_of_element_located((By.XPATH, '//*[@id="manifestBody"]'))
                                )
                                rows = table_body.find_elements(By.XPATH, ".//tr")  # 重新获取所有行

                                found_in_row = True
                                break  # 跳出当前行处理
                        if found_in_row:
                            break  # 退出外层循环
            except Exception as e:
                continue  # 如果发生错误，继续处理下一个记录
        time.sleep(0.5)
        update_output_text(output_text, "匹配结果:", found_records)

    update_output_text(output_text, current_title)
    input("按 Enter 键关闭浏览器...")
    driver.quit()


def statuschange_program(account, password, output_text):
    expiration_date = expiration_date1
    now = datetime.now()
    func_name = inspect.currentframe().f_code.co_name  # 自动获取当前函数名

    if expiration_date and now > expiration_date:
        if not is_user_allowed(func_name, account):
            update_output_text(output_text, "程序已过期，请联系Larry获取更新版本。\n\n")
            exit()

    # 获取用户主目录
    user_home = os.path.expanduser("~")

    # 检测可能的桌面路径
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    # 查找存在的桌面路径
    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "extract.xlsx")
        if os.path.exists(file_path):
            update_output_text(output_text, f"找到文件：{file_path}\n")
        else:
            # 创建空的 Excel 文件
            wb = Workbook()
            wb.save(file_path)
            update_output_text(output_text, f"未找到文件，已创建新文件：{file_path}\n")
            sys.exit()  # 程序立即停止
    else:
        update_output_text(output_text, "未找到有效的桌面路径\n")
        sys.exit()  # 程序立即停止

    # 读取 Excel 文件
    df = pd.read_excel(file_path, header=None, dtype=str)  # 如果没有列名，使用 header=None

    # 通过 iloc 访问第一列（假设是 A 列）
    a_column = df.iloc[:, 0]  # 选择第一列

    # 过滤掉 'na' 和 NaN 值
    filtered_list = a_column[a_column.notna() & (a_column != 'na')].tolist()
    update_output_text(output_text, f"所有需要处理的inbond: {filtered_list}\n")

    try:
        # 配置 ChromeOptions
        options = webdriver.ChromeOptions()
        chrome_binary = r"C:\Program Files\Google\Chrome\Application\chrome.exe"
        options.binary_location = chrome_binary
        options.add_argument("--no-sandbox")
        options.add_argument("--disable-dev-shm-usage")

        # 检查 Chrome 可执行文件是否存在
        if os.path.exists(chrome_binary):
            update_output_text(output_text, f"Chrome 可执行文件存在: {chrome_binary}\n")
        else:
            update_output_text(output_text, f"Chrome 可执行文件不存在: {chrome_binary}\n")
            raise FileNotFoundError(f"Chrome 可执行文件未找到: {chrome_binary}")

        # 获取 ChromeDriver 路径和版本
        try:
            driver_path = ChromeDriverManager().install()
            update_output_text(output_text, f"ChromeDriver 路径: {driver_path}\n")
            # 检查 ChromeDriver 版本
            driver_version = subprocess.check_output([driver_path, "--version"]).decode().strip()
            update_output_text(output_text, f"ChromeDriver 版本: {driver_version}\n")
        except Exception as e:
            update_output_text(output_text, f"获取 ChromeDriver 路径或版本失败: {str(e)}\n")
            raise

        # 检查系统 PATH
        system_path = os.environ.get("PATH", "")
        update_output_text(output_text, f"系统 PATH: {system_path}\n")

        # 初始化 Chrome 浏览器
        update_output_text(output_text, "开始初始化 ChromeDriver...\n")
        driver = webdriver.Chrome(service=Service(driver_path), options=options)
        update_output_text(output_text, "ChromeDriver 初始化成功\n")

    except webdriver.WebDriverException as wde:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (WebDriverException): {str(wde)}\n")
        update_output_text(output_text, f"堆栈跟踪: {traceback.format_exc()}\n")
        raise
    except FileNotFoundError as fnfe:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (FileNotFoundError): {str(fnfe)}\n")
        raise
    except Exception as e:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (未知错误): {str(e)}\n")
        update_output_text(output_text, f"堆栈跟踪: {traceback.format_exc()}\n")
        raise
    url = "https://www.netchb.com/app/home.do"
    driver.get(url)

    WebDriverWait(driver, 20).until(
        EC.presence_of_element_located((By.XPATH, '//*[@id="lName"]'))
    ).send_keys(account)

    # 等待 Password 输入框出现并输入密码
    WebDriverWait(driver, 20).until(
        EC.presence_of_element_located((By.XPATH, '//*[@id="pass"]'))
    ).send_keys(password)

    xpath = '//*[@id="loginForm"]/div[2]/input'
    login_button = driver.find_element(By.XPATH, xpath)
    login_button.click()
    target_url = f"https://www.netchb.com/app/inbond/inbondMenu.do?itNo={'054294590'}"
    # 打开页面
    driver.get(target_url)
    # 遍历 filtered_list 中的每个项目
    for item in filtered_list:

        if windowname != "task":
            update_output_text(output_text, "窗口已关闭，程序终止。\n")
            sys.exit()  # 窗口已关闭，退出程序

        target_url = f"https://www.netchb.com/app/inbond/inbondMenu.do?itNo={item}"
        # 打开页面
        driver.get(target_url)

        current_title = driver.title
        update_output_text(output_text, f"正在处理 {item}")

        try:
            # 查找特定的元素，增加最长等待时间
            element_xpath = '/html/body/table/tbody/tr[2]/td[1]/table[1]/tbody/tr[10]/td[2]/a'

            # 等待最多 20 秒，直到元素可点击
            element = WebDriverWait(driver, 50).until(
                EC.element_to_be_clickable((By.XPATH, element_xpath))
            )

            # 如果元素存在并且可点击，点击它
            element.click()

            # 等待新页面加载完成
            select_xpath = '//*[@id="changeInbondStatusTo"]'
            select_element = WebDriverWait(driver, 20).until(
                EC.presence_of_element_located((By.XPATH, select_xpath))
            )

            # 使用 Select 类选择 "Accepted" 选项
            select = Select(select_element)
            select.select_by_value("ACCEPTED")  # 使用 value 属性选择 "Accepted"

            update_output_text(output_text, f"Successfully selected 'Accepted' for {item}.")

            button_xpath = '//*[@id="changeInbondStatusButton"]'
            target_button = WebDriverWait(driver, 20).until(
                EC.element_to_be_clickable((By.XPATH, button_xpath))
            )
            target_button.click()
            update_output_text(output_text, f"Successfully clicked the target button for {item}.")

        except Exception as e:
            # 如果元素未找到或不可点击，打印消息
            update_output_text(output_text, f"没有找到元素或发生错误 {item}！错误: {e}")

    # 等待用户输入后关闭浏览器
    input("按 Enter 键关闭浏览器...")
    driver.quit()


def del_program(account, password, output_text):
    expiration_date = expiration_date1
    now = datetime.now()
    func_name = inspect.currentframe().f_code.co_name  # 自动获取当前函数名

    if expiration_date and now > expiration_date:
        if not is_user_allowed(func_name, account):
            update_output_text(output_text, "程序已过期，请联系Larry获取更新版本。\n\n")
            exit()

    # 获取用户主目录
    user_home = os.path.expanduser("~")

    # 检测可能的桌面路径
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    # 查找存在的桌面路径
    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "extract.xlsx")
        if os.path.exists(file_path):
            update_output_text(output_text, f"找到文件：{file_path}\n")
        else:
            # 创建空的 Excel 文件
            wb = Workbook()
            wb.save(file_path)
            update_output_text(output_text, f"未找到文件，已创建新文件：{file_path}\n")
            sys.exit()  # 程序立即停止
    else:
        update_output_text(output_text, "未找到有效的桌面路径\n")
        sys.exit()  # 程序立即停止

    # 读取 Excel 文件
    df = pd.read_excel(file_path, header=None, dtype=str)  # 如果没有列名，使用 header=None

    # 通过 iloc 访问第一列（假设是 A 列）
    a_column = df.iloc[:, 0]  # 选择第一列

    # 过滤掉 'na' 和 NaN 值
    filtered_list = a_column[a_column.notna() & (a_column != 'na')].tolist()
    update_output_text(output_text, f"所有需要操作的inbond: {filtered_list}\n")

    try:
        # 配置 ChromeOptions
        options = webdriver.ChromeOptions()
        chrome_binary = r"C:\Program Files\Google\Chrome\Application\chrome.exe"
        options.binary_location = chrome_binary
        options.add_argument("--no-sandbox")
        options.add_argument("--disable-dev-shm-usage")

        # 检查 Chrome 可执行文件是否存在
        if os.path.exists(chrome_binary):
            update_output_text(output_text, f"Chrome 可执行文件存在: {chrome_binary}\n")
        else:
            update_output_text(output_text, f"Chrome 可执行文件不存在: {chrome_binary}\n")
            raise FileNotFoundError(f"Chrome 可执行文件未找到: {chrome_binary}")

        # 获取 ChromeDriver 路径和版本
        try:
            driver_path = ChromeDriverManager().install()
            update_output_text(output_text, f"ChromeDriver 路径: {driver_path}\n")
            # 检查 ChromeDriver 版本
            driver_version = subprocess.check_output([driver_path, "--version"]).decode().strip()
            update_output_text(output_text, f"ChromeDriver 版本: {driver_version}\n")
        except Exception as e:
            update_output_text(output_text, f"获取 ChromeDriver 路径或版本失败: {str(e)}\n")
            raise

        # 检查系统 PATH
        system_path = os.environ.get("PATH", "")
        update_output_text(output_text, f"系统 PATH: {system_path}\n")

        # 初始化 Chrome 浏览器
        update_output_text(output_text, "开始初始化 ChromeDriver...\n")
        driver = webdriver.Chrome(service=Service(driver_path), options=options)
        update_output_text(output_text, "ChromeDriver 初始化成功\n")

    except webdriver.WebDriverException as wde:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (WebDriverException): {str(wde)}\n")
        update_output_text(output_text, f"堆栈跟踪: {traceback.format_exc()}\n")
        raise
    except FileNotFoundError as fnfe:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (FileNotFoundError): {str(fnfe)}\n")
        raise
    except Exception as e:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (未知错误): {str(e)}\n")
        update_output_text(output_text, f"堆栈跟踪: {traceback.format_exc()}\n")
        raise
    url = "https://www.netchb.com/app/home.do"
    driver.get(url)

    WebDriverWait(driver, 20).until(
        EC.presence_of_element_located((By.XPATH, '//*[@id="lName"]'))
    ).send_keys(account)

    # 等待 Password 输入框出现并输入密码
    WebDriverWait(driver, 20).until(
        EC.presence_of_element_located((By.XPATH, '//*[@id="pass"]'))
    ).send_keys(password)

    xpath = '//*[@id="loginForm"]/div[2]/input'
    login_button = driver.find_element(By.XPATH, xpath)
    login_button.click()
    target_url = f"https://www.netchb.com/app/inbond/inbondMenu.do?itNo={'054294590'}"
    # 打开页面
    driver.get(target_url)
    # 遍历 filtered_list 中的每个项目

    for item in filtered_list:
        if windowname != "task":
            update_output_text(output_text, "窗口已关闭，程序终止。\n")
            sys.exit()  # 窗口已关闭，退出程序
        target_url = f"https://www.netchb.com/app/inbond/inbondMenu.do?itNo={item}"
        # 打开页面
        driver.get(target_url)

        current_title = driver.title
        update_output_text(output_text, f"正在处理{item}\n")

        try:
            # 查找特定的元素，增加最长等待时间
            element_xpath = '/html/body/table/tbody/tr[2]/td[1]/table[1]/tbody/tr[8]/td[2]/a'

            # 等待最多 20 秒，直到元素可点击
            element = WebDriverWait(driver, 50).until(
                EC.element_to_be_clickable((By.XPATH, element_xpath))
            )

            # 如果元素存在并且可点击，点击它
            element.click()
            try:
                # 查找特定的元素，增加最长等待时间
                element_xpath = '/html/body/table/tbody/tr[2]/td[2]/table[3]/tbody/tr[2]/td/input'

                # 等待最多 20 秒，直到元素可点击
                element = WebDriverWait(driver, 50).until(
                    EC.element_to_be_clickable((By.XPATH, element_xpath))
                )

                # 如果元素存在并且可点击，点击它
                element.click()


            except Exception as e:
                update_output_text(output_text, f"点击确认按钮时出错：{e}\n")

                # 如果元素未找到或不可点击，打印消息

        except Exception as e:
            # 如果元素未找到或不可点击，打印消息
            update_output_text(output_text, f"没有找到元素 {item} 的按钮！错误: {e}\n")

    # 等待用户输入后关闭浏览器
    input("按 Enter 键关闭浏览器...")
    driver.quit()


def delallinbond_program(account, password, output_text):
    expiration_date = expiration_date1
    now = datetime.now()
    func_name = inspect.currentframe().f_code.co_name  # 自动获取当前函数名

    if expiration_date and now > expiration_date:
        if not is_user_allowed(func_name, account):
            update_output_text(output_text, "程序已过期，请联系Larry获取更新版本。\n\n")
            exit()

    # 获取用户主目录
    user_home = os.path.expanduser("~")

    # 检测可能的桌面路径
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    # 查找存在的桌面路径
    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "extract.xlsx")
        if os.path.exists(file_path):
            update_output_text(output_text, f"找到文件：{file_path}\n\n")
        else:
            # 创建空的 Excel 文件
            wb = Workbook()
            wb.save(file_path)
            update_output_text(output_text, f"未找到文件，已创建新文件：{file_path}\n\n")
            sys.exit()  # 程序立即停止
    else:
        update_output_text(output_text, "未找到有效的桌面路径\n")
        sys.exit()  # 程序立即停止

    # 读取 Excel 文件
    df = pd.read_excel(file_path, header=None, dtype=str)  # 如果没有列名，使用 header=None

    # 通过 iloc 访问第一列（假设是 A 列）
    a_column = df.iloc[:, 0]  # 选择第一列

    # 过滤掉 'na' 和 NaN 值
    filtered_list = a_column[a_column.notna() & (a_column != 'na')].tolist()
    update_output_text(output_text, f"所有需要操作的inbond: {filtered_list}\n")

    try:
        # 配置 ChromeOptions
        options = webdriver.ChromeOptions()
        chrome_binary = r"C:\Program Files\Google\Chrome\Application\chrome.exe"
        options.binary_location = chrome_binary
        options.add_argument("--no-sandbox")
        options.add_argument("--disable-dev-shm-usage")

        # 检查 Chrome 可执行文件是否存在
        if os.path.exists(chrome_binary):
            update_output_text(output_text, f"Chrome 可执行文件存在: {chrome_binary}\n")
        else:
            update_output_text(output_text, f"Chrome 可执行文件不存在: {chrome_binary}\n")
            raise FileNotFoundError(f"Chrome 可执行文件未找到: {chrome_binary}")

        # 获取 ChromeDriver 路径和版本
        try:
            driver_path = ChromeDriverManager().install()
            update_output_text(output_text, f"ChromeDriver 路径: {driver_path}\n")
            # 检查 ChromeDriver 版本
            driver_version = subprocess.check_output([driver_path, "--version"]).decode().strip()
            update_output_text(output_text, f"ChromeDriver 版本: {driver_version}\n")
        except Exception as e:
            update_output_text(output_text, f"获取 ChromeDriver 路径或版本失败: {str(e)}\n")
            raise

        # 检查系统 PATH
        system_path = os.environ.get("PATH", "")
        update_output_text(output_text, f"系统 PATH: {system_path}\n")

        # 初始化 Chrome 浏览器
        update_output_text(output_text, "开始初始化 ChromeDriver...\n")
        driver = webdriver.Chrome(service=Service(driver_path), options=options)
        update_output_text(output_text, "ChromeDriver 初始化成功\n")

    except webdriver.WebDriverException as wde:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (WebDriverException): {str(wde)}\n")
        update_output_text(output_text, f"堆栈跟踪: {traceback.format_exc()}\n")
        raise
    except FileNotFoundError as fnfe:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (FileNotFoundError): {str(fnfe)}\n")
        raise
    except Exception as e:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (未知错误): {str(e)}\n")
        update_output_text(output_text, f"堆栈跟踪: {traceback.format_exc()}\n")
        raise
    url = "https://www.netchb.com/app/home.do"
    driver.get(url)

    WebDriverWait(driver, 20).until(
        EC.presence_of_element_located((By.XPATH, '//*[@id="lName"]'))
    ).send_keys(account)

    # 等待 Password 输入框出现并输入密码
    WebDriverWait(driver, 20).until(
        EC.presence_of_element_located((By.XPATH, '//*[@id="pass"]'))
    ).send_keys(password)

    xpath = '//*[@id="loginForm"]/div[2]/input'
    login_button = driver.find_element(By.XPATH, xpath)
    login_button.click()
    target_url = f"https://www.netchb.com/app/inbond/inbondMenu.do?itNo={'054294590'}"
    # 打开页面
    driver.get(target_url)
    # 遍历 filtered_list 中的每个项目

    for item in filtered_list:
        if windowname != "task":
            update_output_text(output_text, "窗口已关闭，程序终止。\n")
            sys.exit()  # 窗口已关闭，退出程序
        target_url = f"https://www.netchb.com/app/inbond/inbondMenu.do?itNo={item}"
        # 打开页面
        driver.get(target_url)

        try:
            # 等待页面加载
            wait = WebDriverWait(driver, 10)
            table_body = wait.until(
                EC.presence_of_element_located((By.XPATH, '//*[@id="manifestBody"]'))
            )

            while True:
                try:
                    # 查找删除按钮并点击
                    delete_button = driver.find_element(By.XPATH,
                                                        '/html/body/table/tbody/tr[2]/td[2]/table[3]/tbody/tr/td[1]/table[2]/tbody/tr[4]/td[5]/input')
                    delete_button.click()
                    time.sleep(0.5)

                    # 处理弹窗
                    try:
                        alert = driver.switch_to.alert  # 正确方式，直接访问 alert
                        alert.accept()  # 点击确认按钮
                        time.sleep(0.5)
                    except NoAlertPresentException:
                        update_output_text(output_text, f"没有弹窗，跳过弹窗处理。")

                except NoSuchElementException:
                    update_output_text(output_text, f"元素 {filter} 的删除按钮不存在，退出循环。")

                    break

        except Exception as e:
            update_output_text(output_text, f"错误发生在 {filter}: {e}")


def headeredit_program(account, password, output_text, inputnum):
    expiration_date = expiration_date1
    now = datetime.now()
    func_name = inspect.currentframe().f_code.co_name  # 自动获取当前函数名

    if expiration_date and now > expiration_date:
        if not is_user_allowed(func_name, account):
            update_output_text(output_text, "程序已过期，请联系Larry获取更新版本。\n\n")
            exit()

    user_home = os.path.expanduser("~")
    possible_paths = [
        os.path.join(user_home, "Desktop"),
        os.path.join(user_home, "桌面"),
        os.path.join(user_home, "OneDrive", "Desktop"),
        os.path.join(user_home, "OneDrive", "桌面")
    ]

    desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

    if desktop_path:
        file_path = os.path.join(desktop_path, "extract.xlsx")
        if os.path.exists(file_path):
            update_output_text(output_text, f"找到文件：{file_path}\n\n")
        else:
            wb = Workbook()
            wb.save(file_path)
            update_output_text(output_text, f"未找到文件，已创建新文件：{file_path}\n\n")
            sys.exit()
    else:
        update_output_text(output_text, "未找到有效的桌面路径\n\n")
        sys.exit()

    if desktop_path:
        excel_path = os.path.join(desktop_path, "headeredit.xlsx")
        if os.path.exists(excel_path):
            update_output_text(output_text, f"找到文件：{excel_path}\n\n")
        else:
            wb = Workbook()
            wb.save(excel_path)
            update_output_text(output_text, f"未找到文件，已创建新文件：{excel_path}\n\n")
            sys.exit()
    else:
        update_output_text(output_text, "未找到有效的桌面路径\n\n")
        sys.exit()

    if inputnum not in ["61", "63"]:
        update_output_text(output_text, "无效输入，请输入61或63！\n\n")
        exit()

    try:
        workbook = openpyxl.load_workbook(excel_path)
        sheet = workbook.active
    except Exception as e:
        update_output_text(output_text, f"无法打开Excel文件：{e}\n\n")
        exit()

    if inputnum == "63":
        editdate = sheet["B2"].value or "N/A"
        editcarrier = sheet["B3"].value or "N/A"
        editvessel = sheet["B4"].value or "N/A"
        editdestination = sheet["B5"].value or "N/A"
        editvoyage = sheet["B6"].value or "N/A"
        presentation_port = sheet["B7"].value or "N/A"
        port_of_unlading = sheet["B8"].value or "N/A"
        consigned_to_port = sheet["B9"].value or "N/A"
        goodnow = "N/A"
        CarrierID = sheet["B10"].value or "N/A"
        Entrytype = str(sheet["B11"].value or "N/A")
        Lastfp = "N/A"
    elif inputnum == "61":
        editdate = sheet["I2"].value or "N/A"
        editcarrier = sheet["I3"].value or "N/A"
        editvessel = sheet["I4"].value or "N/A"
        goodnow = sheet["I5"].value or "N/A"
        editvoyage = sheet["I6"].value or "N/A"
        presentation_port = sheet["I7"].value or "N/A"
        port_of_unlading = sheet["I8"].value or "N/A"
        consigned_to_port = sheet["I9"].value or "N/A"
        editdestination = "N/A"
        CarrierID = sheet["I10"].value or "N/A"
        Entrytype = str(sheet["I12"].value or "N/A")
        Lastfp = sheet["I11"].value or "N/A"

    update_output_text(output_text, "提取的数据如下：\n")
    update_output_text(output_text, f"日期: {editdate}\n")
    update_output_text(output_text, f"承运人: {editcarrier}\n")
    update_output_text(output_text, f"船舶: {editvessel}\n")
    update_output_text(output_text, f"目的地: {editdestination}\n")
    update_output_text(output_text, f"GNA: {goodnow}\n")
    update_output_text(output_text, f"航次: {editvoyage}\n")
    update_output_text(output_text, f"Presentation Port: {presentation_port}\n")
    update_output_text(output_text, f"Port of Unlading: {port_of_unlading}\n")
    update_output_text(output_text, f"Consigned to Port: {consigned_to_port}\n")
    update_output_text(output_text, f"carrierid: {CarrierID}\n")
    update_output_text(output_text, f"entrytype: {Entrytype}\n")
    update_output_text(output_text, f"Lastfp: {Lastfp}\n\n")

    df = pd.read_excel(file_path, header=None, dtype=str)
    a_column = df.iloc[:, 0]
    filtered_list = a_column[a_column.notna() & (a_column != 'na')].tolist()
    update_output_text(output_text, f"所有需要操作的inbond: {filtered_list}\n")

    try:
        # 配置 ChromeOptions
        options = webdriver.ChromeOptions()
        chrome_binary = r"C:\Program Files\Google\Chrome\Application\chrome.exe"
        options.binary_location = chrome_binary
        options.add_argument("--no-sandbox")
        options.add_argument("--disable-dev-shm-usage")

        # 检查 Chrome 可执行文件是否存在
        if os.path.exists(chrome_binary):
            update_output_text(output_text, f"Chrome 可执行文件存在: {chrome_binary}\n")
        else:
            update_output_text(output_text, f"Chrome 可执行文件不存在: {chrome_binary}\n")
            raise FileNotFoundError(f"Chrome 可执行文件未找到: {chrome_binary}")

        # 获取 ChromeDriver 路径和版本
        try:
            driver_path = ChromeDriverManager().install()
            update_output_text(output_text, f"ChromeDriver 路径: {driver_path}\n")
            # 检查 ChromeDriver 版本
            driver_version = subprocess.check_output([driver_path, "--version"]).decode().strip()
            update_output_text(output_text, f"ChromeDriver 版本: {driver_version}\n")
        except Exception as e:
            update_output_text(output_text, f"获取 ChromeDriver 路径或版本失败: {str(e)}\n")
            raise

        # 检查系统 PATH
        system_path = os.environ.get("PATH", "")
        update_output_text(output_text, f"系统 PATH: {system_path}\n")

        # 初始化 Chrome 浏览器
        update_output_text(output_text, "开始初始化 ChromeDriver...\n")
        driver = webdriver.Chrome(service=Service(driver_path), options=options)
        update_output_text(output_text, "ChromeDriver 初始化成功\n")

    except webdriver.WebDriverException as wde:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (WebDriverException): {str(wde)}\n")
        update_output_text(output_text, f"堆栈跟踪: {traceback.format_exc()}\n")
        raise
    except FileNotFoundError as fnfe:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (FileNotFoundError): {str(fnfe)}\n")
        raise
    except Exception as e:
        update_output_text(output_text, f"初始化 ChromeDriver 失败 (未知错误): {str(e)}\n")
        update_output_text(output_text, f"堆栈跟踪: {traceback.format_exc()}\n")
        raise
    url = "https://www.netchb.com/app/home.do"
    driver.get(url)

    WebDriverWait(driver, 20).until(
        EC.presence_of_element_located((By.XPATH, '//*[@id="lName"]'))
    ).send_keys(account)

    WebDriverWait(driver, 20).until(
        EC.presence_of_element_located((By.XPATH, '//*[@id="pass"]'))
    ).send_keys(password)

    xpath = '//*[@id="loginForm"]/div[2]/input'
    login_button = driver.find_element(By.XPATH, xpath)
    login_button.click()

    values_to_update = {
        '//*[@id="pDate"]': editdate,
        '//*[@id="dImp"]': editdate,
        '//*[@id="ed"]': editdate,
        '//*[@id="ad"]': editdate,
        '//*[@id="impC"]': editcarrier,
        '//*[@id="vn"]': editvessel,
        '//*[@id="forDest"]': editdestination,
        '//*[@id="vNo"]': editvoyage,
        '//*[@id="gna"]': goodnow,
        '//*[@id="presPort"]': presentation_port,
        '//*[@id="pu"]': port_of_unlading,
        '//*[@id="usp"]': consigned_to_port,
        '//*[@id="ci"]': CarrierID,
        '//*[@id="lfp"]': Lastfp
    }
    entrytype_xpath = '//*[@id="et"]'
    url = "https://www.netchb.com/app/inbond/inbondMenu.do?itNo=054302382"
    driver.get(url)
    for item in filtered_list:
        if windowname != "task":
            update_output_text(output_text, "窗口已关闭，程序终止。\n")
            sys.exit()
        target_url = f"https://www.netchb.com/app/inbond/inbondMenu.do?itNo={item}"
        driver.get(target_url)

        try:
            element_xpath = '/html/body/table/tbody/tr[2]/td[1]/table[1]/tbody/tr[6]/td[2]/a'
            element = WebDriverWait(driver, 50).until(
                EC.element_to_be_clickable((By.XPATH, element_xpath))
            )
            element.click()
            time.sleep(1)

            if Entrytype != "N/A":
                try:
                    entrytype_element = WebDriverWait(driver, 20).until(
                        EC.element_to_be_clickable((By.XPATH, entrytype_xpath))
                    )
                    select = Select(entrytype_element)
                    select.select_by_value(Entrytype)
                    time.sleep(1)
                except Exception as e:
                    update_output_text(output_text, f"Error setting Entrytype at {entrytype_xpath}: {e}\n")
            else:
                update_output_text(output_text, f"Skipped setting Entrytype because value is 'N/A'.\n")

            for xpath, value in values_to_update.items():
                if value != "N/A":
                    try:
                        field_element = WebDriverWait(driver, 20).until(
                            EC.element_to_be_clickable((By.XPATH, xpath))
                        )
                        field_element.clear()
                        field_element.send_keys(value)
                    except Exception as e:
                        update_output_text(output_text, f"Error updating field at {xpath}: {e}\n")
                else:
                    update_output_text(output_text, f"Skipped updating field at {xpath} because value is 'N/A'.\n")

            time.sleep(2)

            save_xpath = '//*[@id="inbondHeaderForm"]/input[4]'
            saveelement = WebDriverWait(driver, 50).until(
                EC.element_to_be_clickable((By.XPATH, save_xpath))
            )
            saveelement.click()

        except Exception as e:
            update_output_text(output_text, f"Error occurred for {item}: {e}\n")

        target_url2 = f"https://www.netchb.com/app/home.do"
        driver.get(target_url2)
        time.sleep(4)

    input("Press Enter to close the browser...")
    driver.quit()


def Steel_Aluminum_dutyprogram(account, password, output_text):
    from seleniumwire import webdriver
    expiration_date = expiration_date1
    now = datetime.now()
    func_name = inspect.currentframe().f_code.co_name  # 自动获取当前函数名

    if expiration_date and now > expiration_date:
        if not is_user_allowed(func_name, account):
            update_output_text(output_text, "程序已过期，请联系Larry获取更新版本。\n\n")
            exit()

    def get_code(account, password):
        data_dict = {}

        user_home = os.path.expanduser("~")
        possible_paths = [
            os.path.join(user_home, "Desktop"),
            os.path.join(user_home, "桌面"),
            os.path.join(user_home, "OneDrive", "Desktop"),
            os.path.join(user_home, "OneDrive", "桌面")
        ]

        desktop_path = next((path for path in possible_paths if os.path.exists(path)), None)

        if desktop_path:
            file_path = os.path.join(desktop_path, "BBCreview.xlsx")
            if os.path.exists(file_path):
                update_output_text(output_text, "已找到BBCreview\n")
                pass
            else:
                # 创建空的 Excel 文件
                wb = Workbook()
                wb.save(file_path)
                update_output_text(output_text, "已创建BBCreview，再次运行即可开始代码\n")
                sys.exit()  # 程序立即停止
        else:
            update_output_text(output_text, "创建excel失败，请联系larry解决\n")
            sys.exit()  # 程序立即停止

        # 固定路径：AppData\Local
        fixed_path = os.path.join(user_home, "AppData", "Local")
        txt_file_path = os.path.join(fixed_path, "origincode.txt")

        if not os.path.exists(txt_file_path):
            try:
                with open(txt_file_path, 'w', encoding='utf-8') as f:
                    pass  # 创建空文件
                update_output_text(output_text, '已匹配至larry本地服务器, 请再点击一次运行以运行\n')
                sys.exit()
            except Exception as e:
                update_output_text(output_text, '连接失败，请联系larry解决\n')
                sys.exit()
        else:
            update_output_text(output_text, '正在像larry服务器传送内容，开始代码\n')
            time.sleep(5)
            update_output_text(output_text, '已连接larry本地服务器，开始代码\n')

        chrome_options = webdriver.ChromeOptions()
        chrome_options.add_argument("--start-maximized")  # 启动时最大化
        chrome_options.add_argument("--disable-gpu")  # 解决某些系统的图形渲染问题
        chrome_options.add_argument("--no-sandbox")  # 非root用户需要此参数
        chrome_options.add_argument("--disable-dev-shm-usage")  # 避免某些共享内存问题
        chrome_options.add_argument("--always-on-top")  # 窗口置顶 (实验性参数)
        chrome_options.add_argument("--force-device-scale-factor=0.5")  # 设置缩放比例为50%

        # 启动 Chrome 浏览器并加载已保存的用户数据
        driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=chrome_options)
        driver.set_window_size(1920, 1080)

        # 通过 JavaScript 强制设置缩放比例
        driver.get("https://www.google.com")
        driver.execute_script("document.body.style.zoom='50%'")
        url = "https://my.acelynknavigator.com/Account/Login.aspx?ReturnUrl=%2fDesktop%2fDefault.aspx"
        driver.get(url)
        driver.maximize_window()  # 最大化窗口

        all_tabs = driver.window_handles
        all_tabs = driver.window_handles

        # 遍历所有窗口，关闭不需要的 "data:" 标签页
        for tab in all_tabs:
            driver.switch_to.window(tab)
            if "data:" in driver.current_url:
                driver.close()  # 关闭 "data:" 标签页

        # 重新获取当前所有窗口句柄
        all_tabs = driver.window_handles

        # 如果有剩余窗口，切换到第一个
        if all_tabs:
            driver.switch_to.window(all_tabs[0])

        try:
            # 等待页面加载并检查是否包含 "sign"
            WebDriverWait(driver, 10).until(
                lambda d: "sign" in d.page_source.lower()  # 等待直到页面包含 "sign"
            )
            print("'sign' found in page source. Continuing...")
        except Exception as e:
            print("Timeout or error while waiting for 'sign':", e)
            driver.quit()
            exit()

        # 输入账号和密码
        username = account  # 替换为实际账号
        password = password  # 替换为实际密码

        # 定位到账号和密码输入框
        username_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_UserName"]')
        username_field.clear()  # 清除输入框中的任何内容
        username_field.send_keys(username)  # 输入用户名

        # 输入密码
        password_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_Password"]')
        password_field.clear()  # 清除输入框中的任何内容
        password_field.send_keys(password)  # 输入密码

        # 点击登录按钮
        login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")  # 替换为实际 ID
        login_button.click()
        print("Current page title is:", driver.title)
        WebDriverWait(driver, 10).until(EC.title_contains("Compliance"))  # 等待页面标题更新为登录后的内容

        try:
            # 定位到登录按钮并点击
            login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")
            login_button.click()

            # 等待检查是否有警告框弹出
            try:
                logout_button = WebDriverWait(driver, 10).until(
                    EC.element_to_be_clickable((By.XPATH, "//*[@id='lbtLogOutAllSessions']"))
                )
                logout_button.click()
                print("Clicked the logout button in the alert.")

                # 等待页面刷新（可以根据 URL 变化或某个标志性元素来确认）
                WebDriverWait(driver, 10).until(
                    EC.presence_of_element_located((By.ID, "LoginMenu_LoginButton"))  # 确保登录按钮存在
                )
                time.sleep(2)
                username_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_UserName"]')
                username_field.clear()  # 清除输入框中的任何内容
                username_field.send_keys(username)  # 输入用户名

                # 输入密码
                password_field = driver.find_element(By.XPATH, '//*[@id="LoginMenu_Password"]')
                password_field.clear()  # 清除输入框中的任何内容
                password_field.send_keys(password)  # 输入密码
                # 重新定位登录按钮
                login_button = driver.find_element(By.ID, "LoginMenu_LoginButton")
                login_button.click()
                print("Clicked the login button.")

            except TimeoutException:
                print("No alert appeared, proceeding with the login.")

            # 等待页面跳转并检查登录后页面标题
            WebDriverWait(driver, 10).until(
                EC.title_contains("Dashboard")  # 这里用登录后的页面标题的一个关键字
            )
            print("Login successful. Page title is:", driver.title)

        except (TimeoutException, NoSuchElementException) as e:
            print(f"Error occurred during login: {e}")
        outputdf = pd.DataFrame(columns=["entry_number", "status_img_src", "pga_img_src", "first_column_data"])
        driver.get("https://my.acelynknavigator.com/Desktop/Default.aspx")
        step_status = True

        def check_alert(driver):
            try:
                time.sleep(1)
                alert = driver.switch_to.alert
                alert_text = alert.text
                print("弹窗内容:", alert_text)

                if "cotton" not in alert_text.lower():
                    alert.accept()
                    print("已点击确认按钮")
                else:
                    alert.dismiss()
                    print("检测到 'cotton'，已点击取消按钮")

                time.sleep(1)
            except NoAlertPresentException:
                pass  # 没有弹窗，跳过

        def wait_for_block_to_disappear(driver, timeout=40, check_interval=1):
            end_time = time.time() + timeout
            while time.time() < end_time:
                try:
                    # 查找遮罩层
                    blocking_elements = driver.find_elements(By.CSS_SELECTOR, ".blockUI.blockOverlay")
                    if not blocking_elements:
                        print("✅ 阻挡元素消失，继续操作")
                        return
                    print("⏳ 检测到遮罩层，等待中...")
                    time.sleep(check_interval)
                except UnexpectedAlertPresentException:

                    try:
                        alert = driver.switch_to.alert
                        print("⚠️ 检测到 alert 弹窗：", alert.text)
                        alert.accept()
                        print("✅ 已点击确认关闭 alert")
                        time.sleep(1)
                    except NoAlertPresentException:
                        print("❌ 想处理 alert，但找不到")
                    continue
                except Exception as e:
                    print(f"⚠️ 检测遮罩层时出现错误: {e}")
                    time.sleep(check_interval)
                    continue

        def open_entry(driver):
            try:
                driver.switch_to.default_content()
                print("✅ 已返回主页面")
            except Exception as e:
                print(f"❌ 返回主页面失败: {e}")

            try:
                # 检查 iframe
                iframes = driver.find_elements(By.TAG_NAME, "iframe")
                print(f"🔎 检测到 {len(iframes)} 个 iframe")
                iframe_switched = False
                if iframes:
                    for i, iframe in enumerate(iframes):
                        try:
                            driver.switch_to.frame(iframe)
                            print(f"✅ 切换到 iframe {i}")
                            driver.find_element(By.XPATH,
                                                "(//td[contains(@id, 'EntrySummary')]//ul[@class='nav2']//img)[1]")
                            print("✅ 悬停元素在 iframe 中")
                            iframe_switched = True
                            break
                        except:
                            driver.switch_to.default_content()
                            print(f"❌ iframe {i} 中无目标元素，切换回主页面")
                else:
                    print("✅ 无 iframe")

                # 定位悬停元素并提取 <td> 的 id
                img_xpath = "(//td[contains(@id, 'EntrySummary')]//ul[@class='nav2']//img)[1]"
                print(f"🔍 尝试定位悬停元素: {img_xpath}")
                img_elements = driver.find_elements(By.XPATH, img_xpath)
                print(f"🔎 找到 {len(img_elements)} 个悬停元素")
                if len(img_elements) > 1:
                    print("⚠️ 警告: 悬停 XPath 匹配到多个元素，可能导致错误")
                    for i, elem in enumerate(img_elements):
                        print(f"🔎 悬停元素 {i}: {elem.get_attribute('outerHTML')}")
                img_element = img_elements[0] if img_elements else driver.find_element(By.XPATH, img_xpath)
                print(f"✅ 悬停元素: {img_element.get_attribute('outerHTML')}")

                # 获取父 <td> 的 id
                td_element = img_element.find_element(By.XPATH, "./ancestor::td[contains(@id, 'EntrySummary')]")
                td_id = td_element.get_attribute("id")
                print(f"✅ 找到父 <td> id: {td_id}")

                # 悬停并等待菜单加载
                ActionChains(driver).move_to_element(img_element).perform()
                print("✅ 已执行悬停操作")
                try:
                    WebDriverWait(driver, 5).until(
                        EC.presence_of_element_located((By.XPATH, "//a[contains(@class,'shipment-row')]"))
                    )
                    print("✅ 菜单已加载")
                except TimeoutException:
                    print("❌ 菜单未加载，可能悬停失败")

                # 检查弹窗
                def check_alert(driver):
                    try:
                        alert = driver.switch_to.alert
                        alert.accept()
                        print("✅ 已关闭弹窗")
                    except:
                        print("✅ 无弹窗")

                check_alert(driver)

                # 检查高 z-index 元素
                overlays = driver.find_elements(By.XPATH,
                                                "//*[contains(@style, 'z-index') and not(contains(@style, 'z-index: 0'))]")
                print(f"🔎 检测到 {len(overlays)} 个高 z-index 元素")
                for overlay in overlays[:3]:
                    print(f"🔎 覆盖层: {overlay.get_attribute('outerHTML')}")

                # 定位 Edit 按钮，使用父 <td> 的 id 约束
                timeout = 10
                interval = 1
                start_time = time.time()
                edit_xpath = f"//td[@id='{td_id}']//a[contains(@class,'shipment-row') and .//img[contains(@src,'edit_30x30.png')]]"
                print(f"🔍 尝试定位 Edit 按钮: {edit_xpath}")
                edit_elements = driver.find_elements(By.XPATH, edit_xpath)
                print(f"🔎 找到 {len(edit_elements)} 个 Edit 按钮")
                if len(edit_elements) > 1:
                    print("⚠️ 警告: Edit XPath 仍匹配到多个元素")
                    for i, elem in enumerate(edit_elements):
                        print(f"🔎 Edit 按钮 {i}: {elem.get_attribute('outerHTML')}")
                elif len(edit_elements) == 0:
                    print("❌ Edit 按钮未找到，XPath 可能错误或元素未加载")
                    print(
                        "🔍 尝试备用 XPath: //a[contains(@class,'shipment-row') and .//img[contains(@src,'edit_30x30.png')]]")
                    edit_elements = driver.find_elements(By.XPATH,
                                                         "//a[contains(@class,'shipment-row') and .//img[contains(@src,'edit_30x30.png')]]")
                    print(f"🔎 备用 XPath 找到 {len(edit_elements)} 个 Edit 按钮")
                    for i, elem in enumerate(edit_elements):
                        print(f"🔎 备用 Edit 按钮 {i}: {elem.get_attribute('outerHTML')}")

                while True:
                    try:
                        edit_img = WebDriverWait(driver, interval).until(
                            EC.element_to_be_clickable((By.XPATH, edit_xpath))
                        )
                        print(f"✅ Edit 按钮定位成功: {edit_img.get_attribute('outerHTML')}")
                        print(f"🔎 元素可见: {edit_img.is_displayed()}, 元素可点击: {edit_img.is_enabled()}")
                        try:
                            edit_img.click()
                            print("✅ 点击 Edit 按钮成功")
                            break
                        except ElementClickInterceptedException as e:
                            print(f"❌ 点击被拦截: {e}")
                            print("🔍 尝试 JavaScript 点击")
                            driver.execute_script("arguments[0].click();", edit_img)
                            print("✅ 使用 JavaScript 点击 Edit 按钮")
                            break
                    except TimeoutException as e:
                        elapsed = time.time() - start_time
                        print(f"❌ TimeoutException: {e}")
                        if elapsed >= timeout:
                            print("❌ 超过最大等待时间，点击失败")
                            print("📄 当前页面 HTML（部分）:")
                            edit_elements = driver.find_elements(By.XPATH, edit_xpath)
                            if edit_elements:
                                print(f"🔎 Edit 按钮存在但不可点击: {edit_elements[0].get_attribute('outerHTML')}")
                            else:
                                print("🔎 Edit 按钮未在 DOM 中找到")
                            break
                        else:
                            print("❌ 元素未可点，等待1秒后重试...")
                            time.sleep(interval)
                    except ElementClickInterceptedException as e:
                        elapsed = time.time() - start_time
                        print(f"❌ ElementClickInterceptedException: {e}")
                        if elapsed >= timeout:
                            print("❌ 超过最大等待时间，点击失败")
                            print("📄 当前页面 HTML（部分）:")
                            edit_elements = driver.find_elements(By.XPATH, edit_xpath)
                            if edit_elements:
                                print(f"🔎 Edit 按钮存在但被遮挡: {edit_elements[0].get_attribute('outerHTML')}")
                            break
                        else:
                            print("❌ 元素被拦截，等待1秒后重试...")
                            time.sleep(interval)

                # 切换回主页面
                if iframe_switched:
                    driver.switch_to.default_content()
                    print("✅ 切换回主页面")

            except Exception as e:
                print(f"❌ 发生错误: {e}")
                print("📄 当前页面 HTML（部分）:")
                edit_elements = driver.find_elements(By.XPATH, edit_xpath)
                if edit_elements:
                    print(f"🔎 Edit 按钮: {edit_elements[0].get_attribute('outerHTML')}")
                else:
                    print("🔎 Edit 按钮未找到")

        def search_entry_num(entry_number, timeout=5):
            driver.switch_to.default_content()

            wait_for_block_to_disappear(driver)
            start_time = time.time()
            while True:
                try:

                    find_element = WebDriverWait(driver, 10).until(
                        EC.visibility_of_element_located(
                            (By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/button[2]/span[2]"))
                    )
                    # 模拟鼠标悬停
                    actions = ActionChains(driver)
                    actions.move_to_element(find_element).perform()
                    # 尝试定位并输入 entry_number
                    input_box = WebDriverWait(driver, 3).until(
                        EC.visibility_of_element_located((By.XPATH, "//*[@id='advancedSearch']/div/div[8]/input"))
                    )
                    input_box.clear()
                    input_box.send_keys(entry_number)

                    # 尝试点击按钮
                    search_button = WebDriverWait(driver, 3).until(
                        EC.element_to_be_clickable(
                            (By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/div[3]/div/div[13]/a[1]"))
                    )
                    search_button.click()

                    break  # 成功后跳出循环

                except (ElementNotInteractableException, NoSuchElementException, TimeoutException) as e:
                    if time.time() - start_time > timeout:
                        return "超时"
                        break
                    else:
                        time.sleep(1)  # 等待1秒后重试

        def safe_do(driver, action, description="", retries=2, retry_delay=0.5):
            for attempt in range(retries):
                try:
                    check_alert(driver)
                    result = action()
                    check_alert(driver)
                    return result
                except Exception as e:
                    print(f"⚠️ {description} 第 {attempt + 1} 次尝试失败: {e}")
                    check_alert(driver)
                    if attempt < retries - 1:
                        time.sleep(retry_delay)
                    else:
                        print(f"❌ {description} 所有尝试失败")
                        return "tryfalse"

        def wait_for_autocomplete(driver, xpath: str, interval: float, duration: float):
            import time
            from selenium.common.exceptions import NoSuchElementException
            from selenium.webdriver.common.by import By

            start_time = time.time()

            while time.time() - start_time < duration:
                try:
                    element = driver.find_element(By.XPATH, xpath)
                    if element.is_displayed():
                        print("✅ 自动补全栏已弹出")
                        time.sleep(1)
                        return True
                except NoSuchElementException:
                    print("🔍 未检测到自动补全栏，继续等待...")

                time.sleep(interval)

            print("❌ 超时未检测到自动补全栏")
            return False

        def data_entry(driver, entry_xpath: str, choose_xpath: str, interval: float, duration: float, content: str):
            try:
                # 清空并输入
                safe_do(driver, lambda: WebDriverWait(driver, 10).until(
                    EC.presence_of_element_located((By.XPATH, entry_xpath))).clear(), "清空输入框")
                safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(""), "输入空内容")
                safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(content), "输入内容")

                # 尝试点击自动补全选项
                import time, re
                start_time = time.time()

                # 提取 ul 的索引
                ul_pattern = re.search(r'ul\[(\d+)\]', choose_xpath)
                if not ul_pattern:
                    print("❌ choose_xpath 无法识别 ul[x] 的格式")
                    return

                base_index = int(ul_pattern.group(1))
                prefix, suffix = choose_xpath.split(f'ul[{base_index}]')

                while time.time() - start_time < duration:
                    for i in range(11):  # 最多尝试 base 到 base+10
                        trial_xpath = f"{prefix}ul[{base_index + i}]{suffix}"
                        print(f"尝试点击: {trial_xpath}")
                        result = safe_do(driver, lambda: WebDriverWait(driver, interval).until(
                            EC.element_to_be_clickable((By.XPATH, trial_xpath))).click(),
                                         f"点击自动补全项 ul[{base_index + i}]")

                        if result != "tryfalse":
                            print(f"✅ 点击成功: {trial_xpath}")
                            return

                print("❌ 所有自动补全尝试失败")

            except Exception as e:
                print("❌ data_entry 函数发生异常：", e)
                check_alert(driver)

        def normal_entry(driver, entry_xpath: str, interval: float, duration: float, content: str):

            try:
                safe_do(driver, lambda: WebDriverWait(driver, 10).until(
                    EC.presence_of_element_located((By.XPATH, entry_xpath))).clear(), "清空输入框")
                safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(""), "输入空内容")
                safe_do(driver, lambda: driver.find_element(By.XPATH, entry_xpath).send_keys(content), "输入内容")

            except Exception as e:
                # 这里捕获其他异常并打印详细信息
                print("❌ 发生其他异常：", e)

        def page_viewd(driver, entry_number):
            try:
                iframe = driver.find_element(By.ID, "iframeInvoices")
                driver.switch_to.frame(iframe)
            except:
                pass

            # 点击前记录当前请求数量
            already_seen = set((r.id for r in driver.requests))

            # 点击 save
            safe_do(driver, lambda: WebDriverWait(driver, 60, 0.5).until(
                EC.element_to_be_clickable((By.XPATH,
                                            "/html/body/form/div[3]/div[2]/div[2]/div/div[2]/div/div[1]/div[1]/div[1]/span[2]/ul/li[1]/a"))
            ).click(), "点击save按钮", retries=1, retry_delay=0.5)

            request_data = None
            max_wait_seconds = 30
            interval = 0.5
            elapsed = 0

            while elapsed < max_wait_seconds:
                for request in driver.requests:
                    if request.id in already_seen:
                        continue
                    if request.response:
                        if "SaveJSONV3" in request.url and request.method == 'POST':
                            payload = decode(request.body, request.headers.get('Content-Encoding', 'identity')).decode()
                            request_data = {
                                "url": request.url,
                                "cookie": request.headers.get("Cookie"),
                                "payload": payload,
                                "status_code": request.response.status_code
                            }
                            break
                if request_data:
                    break
                time.sleep(interval)
                elapsed += interval

            wait_for_block_to_disappear(driver, timeout=600, check_interval=1)

            if request_data is None:
                update_output_text(output_text, f"{entry_number}传输信息至Larry的服务器失败\n")
            else:
                update_output_text(output_text, f"{entry_number}成功传输信息至Larry的服务器\n")
                return request_data

        file_path = os.path.join(desktop_path, "BBCreview.xlsx")
        file_path = file_path
        df = pd.read_excel(file_path, header=None, dtype=str)  # 加 dtype=str 读进来就全是字符串

        # 通过 iloc 访问第一列（假设是 A 列）
        a_column = df.iloc[:, 0]  # 选择第一列
        c_column = df.iloc[:, 2]  # 选择第一列
        # 过滤掉 'na' 和 NaN 值
        filtered_lista = a_column[a_column.notna() & (a_column != 'na')].tolist()
        filtered_listc = c_column[c_column.notna() & (c_column != 'na')].tolist()

        wait_for_block_to_disappear(driver, timeout=40, check_interval=1)
        all_data = {}

        for entry_number in filtered_lista:
            search_entry_num(entry_number, timeout=5)
            wait_for_block_to_disappear(driver, timeout=80, check_interval=1)
            check_alert(driver)
            open_entry(driver)
            safe_do(driver, lambda: WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable(
                    (By.XPATH, "/html/body/div[2]/div[2]/div[1]/div/div[2]/div[3]/div/div[13]/a[2]"))).click(),
                    "点击某个按钮")

            data = page_viewd(driver, entry_number)
            if data:
                all_data[entry_number] = data
            else:
                all_data[entry_number] = None  # 或者你可以选择跳过
            try:
                driver.switch_to.default_content()
                print("成功切换回来")
            except Exception as e:
                print(f"⚠️ 切换回主页面失败: {e}")
                pass
            safe_do(driver, lambda: WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable(
                    (By.XPATH, "/html/body/div[2]/div[2]/div[3]/div/div[1]/div[1]/div[1]/ul/li[36]/span[2]"))).click(),
                    "点击某个按钮")
            wait_for_block_to_disappear(driver, timeout=80, check_interval=1)
            time.sleep(1)
        return all_data, txt_file_path,filtered_listc

    def decode_and_save(encoded_data: str, save_path: str):
        """
        解码 Base64+gzip 压缩的 JSON 数据并保存为格式化的 txt/json 文件
        """
        if not encoded_data.strip():
            print("❌ encoded_data 为空")
            return

        try:
            # base64 解码
            decoded_bytes = base64.b64decode(encoded_data)

            # zlib 解压（带 gzip 头）
            decompressed_bytes = zlib.decompress(decoded_bytes, 16 + zlib.MAX_WBITS)

            # 转成字符串
            json_str = decompressed_bytes.decode('utf-8')

            # 解析为 dict
            data_dict = json.loads(json_str)

            # 保存
            with open(save_path, "w", encoding="utf-8") as f:
                json.dump(data_dict, f, indent=2, ensure_ascii=False)

            print(f"✅ 解码完成，文件已保存到: {save_path}")
        except Exception as e:
            print(f"⚠️ 解码失败: {e}")

    def extract_encoded_data(entry_number, data):
        """
        从单条 data 中提取 encodedData，带异常处理和提示。
        返回 encoded_data 字符串，失败返回 None。
        """
        if data is None:
            print(f"{entry_number} 无数据，跳过")
            return None

        payload_str = data.get('payload')
        if not payload_str:
            print(f"{entry_number} payload字段为空，跳过")
            return None

        try:
            payload_json = json.loads(payload_str)
        except Exception as e:
            print(f"{entry_number} payload解析失败: {e}")
            return None

        encoded_data = payload_json.get("encodedData")
        if not encoded_data:
            print(f"{entry_number} encodedData字段不存在，跳过")
            return None

        return encoded_data

    def find_linenumbers_by_tariff(file_path, target_tariff_no):
        """
        从指定 JSON 文件中，查找所有最后一个 TariffNo 或 TariffNumber 等于 target_tariff_no 的 LineNumber。

        参数：
            file_path: JSON 文件路径（文本文件，内容是 JSON 格式）
            target_tariff_no: 要匹配的税号字符串

        返回：
            符合条件的 LineNumber 列表，找不到返回空列表
        """
        with open(file_path, 'r', encoding='utf-8') as f:
            data = json.load(f)

        def recursive_search(d, result):
            if isinstance(d, dict):
                if "LineNumber" in d and "Tariff" in d:
                    line_number = d["LineNumber"]
                    tariff = d.get("Tariff", [])
                    if isinstance(tariff, list) and tariff:
                        last_tariff = tariff[-1]
                        tariff_no = str(last_tariff.get("TariffNo") or last_tariff.get("TariffNumber") or "").strip()
                        if tariff_no == target_tariff_no:
                            result.append(line_number)
                for v in d.values():
                    recursive_search(v, result)
            elif isinstance(d, list):
                for item in d:
                    recursive_search(item, result)

        results = []
        recursive_search(data, results)
        return results

    def update_warehouse(file_path, stmt_print_date):
        """
        读取 JSON 文件，找到 Warehouse 层级，更新或添加指定的 Warehouse 数据，
        使用传入的日期设置 StmtPrintDate，并自动生成 StmtMonth，
        同时将 AutoCalculateStatementDate 设置为 True。

        参数:
            file_path: JSON 文件路径（文本格式）
            stmt_print_date: 目标 StmtPrintDate（格式: MM/DD/YYYY）

        返回:
            True 修改成功，False 失败
        """
        # 固定的 Warehouse 数据模板
        warehouse_template = {
            "ConsInformalInd": "",
            "PaymentIndicator": "7",
            "StmtPrintDate": stmt_print_date,
            "StmtMonth": ""
        }

        # 验证并解析日期
        try:
            parsed_date = datetime.strptime(stmt_print_date, "%m/%d/%Y")
            warehouse_template["StmtMonth"] = parsed_date.strftime("%m")
            print(f"更新后的 Warehouse 模板: {warehouse_template}")
        except ValueError as e:
            print(f"日期格式错误: {e}，请使用 MM/DD/YYYY 格式")
            return False

        def recursive_update(d):
            if isinstance(d, dict):
                if "Warehouse" in d:
                    d["Warehouse"] = [warehouse_template]
                    d["AutoCalculateStatementDate"] = False
                    print(f"找到并更新 Warehouse: {d['Warehouse']}")
                    print(f"已将 AutoCalculateStatementDate 设置为: {d['AutoCalculateStatementDate']}")
                    return True
                for v in d.values():
                    if recursive_update(v):
                        return True
            elif isinstance(d, list):
                for item in d:
                    if recursive_update(item):
                        return True
            return False

        # 读取 JSON 文件
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
        except Exception as e:
            print(f"读取文件失败: {e}")
            return False

        # 更新 Warehouse 数据和 AutoCalculateStatementDate
        modified = recursive_update(data)

        if not modified:
            print("未找到 Warehouse 层级")
            return False

        # 保存修改后的 JSON 文件
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
            print("文件保存成功")
        except Exception as e:
            print(f"保存文件失败: {e}")
            return False

        return True

    def encode_json_file(txt_path):
        # === 第1步：读取 txt 文件 ===
        with open(txt_path, 'r', encoding='utf-8') as f:
            json_str = f.read()

        # 验证是合法 JSON
        json_obj = json.loads(json_str)

        # 格式化成紧凑 JSON 字符串
        json_str = json.dumps(json_obj, separators=(',', ':'), ensure_ascii=False)

        # === 第2步：gzip 压缩 + base64 编码 ===
        compressed_bytes = gzip.compress(json_str.encode('utf-8'))
        encoded_data = base64.b64encode(compressed_bytes).decode('utf-8')

        return encoded_data

    def upload_encoded_data(
            encoded_data: str,
            importer_id: int,
            reference_number: str,
            cookie: str,
            url: str = "https://my.acelynknavigator.com/Desktop/Invoices/Default.aspx/SaveJSONV3"
    ):
        payload = {
            "encodedData": encoded_data,
            "fileType": "EntrySummary",
            "importerId": importer_id,
            "referenceNumber": reference_number
        }

        headers = {
            "Content-Type": "application/json; charset=UTF-8",
            "Accept": "application/json, text/javascript, */*; q=0.01",
            "Origin": "https://my.acelynknavigator.com",
            "Referer": f"https://my.acelynknavigator.com/Desktop/Invoices/?t=EntrySummary&id={reference_number}",
            "User-Agent": "Mozilla/5.0 (X11; Linux aarch64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36 CrKey/1.54.250320",
            "Cookie": cookie,
            "x-requested-with": "XMLHttpRequest"
        }

        response = requests.post(url, headers=headers, json=payload)

        return response.status_code, response.text

    def check_cookie_and_extract(entry_number, data):
        cookie = data.get("cookie")
        payload_str = data.get("payload")

        if not cookie or not cookie.strip():
            print(f"{entry_number} 没有有效的 cookie，跳过")
            return None
        if not payload_str or not payload_str.strip():
            print(f"{entry_number} payload 为空，跳过")
            return None

        try:
            payload = json.loads(payload_str)
        except Exception as e:
            print(f"{entry_number} payload 解析失败: {e}，跳过")
            return None

        importer_id = payload.get("importerId")
        reference_number = payload.get("referenceNumber")

        if not encoded_data or not encoded_data.strip():
            print(f"{entry_number} 没有有效的 encodedData，跳过")
            return None
        if not importer_id:
            print(f"{entry_number} 没有有效的 importer_id，跳过")
            return None
        if not reference_number or not str(reference_number).strip():
            print(f"{entry_number} 没有有效的 reference_number，跳过")
            return None

        return {
            "cookie": cookie,
            "importer_id": importer_id,
            "reference_number": reference_number,
        }

    all_data, txt_file_path,filtered_listc = get_code(account, password)
    print(all_data)
    for (entry_number, data), fixtime in zip(all_data.items(), filtered_listc):
        encoded_data = extract_encoded_data(entry_number, data)

        # 如果是 None 或者空字符串，跳过
        if not encoded_data or not encoded_data.strip():
            print(f"{entry_number} 没有有效的 encoded_data，跳过")
            update_output_text(output_text, f"\nLarry服务器无法成功上传此entry{entry_number}")
            continue

        decode_and_save(encoded_data, txt_file_path)
        update_warehouse(txt_file_path, fixtime)
        info = check_cookie_and_extract(entry_number, data)
        if info is None:
            update_output_text(output_text, f"\n{entry_number}上传失败")
            continue  # 任何一个信息缺失，跳过

        cookie = info['cookie']
        importer_id = info['importer_id']
        reference_number = info['reference_number']
        encoded_data = encode_json_file(txt_file_path)

        status, text = upload_encoded_data(encoded_data, importer_id, reference_number, cookie)
        if status == 200:
            update_output_text(output_text, f"\n{entry_number} 处理完成\n")
        else:
            update_output_text(output_text, f"\n{entry_number} 处理失败: {status}\n")

        print("状态码:", status)

        print(f"{entry_number} 处理完成\n")
    update_output_text(output_text, f"------------全部处理完成-----------------------------------")

import customtkinter as ctk
from tkinter import messagebox
import threading

ctk.set_appearance_mode("dark")
ctk.set_default_color_theme("blue")

# 用于停止线程的事件
stop_event = threading.Event()


def start_program(account, password, output_text, task_type, mode=None):
    stop_event.clear()  # 清除停止事件，准备开始任务
    if task_type == "QP":
        QP_program(account, password, output_text)
    elif task_type == "inbond提取":
        inbond_program(account, password, output_text)

    elif task_type == "Transmit":
        transmit_program(account, password, output_text)
    elif task_type == "Hold":
        hold_program(account, password, output_text, mode)
    elif task_type == "DelQP":
        del_program(account, password, output_text)
    elif task_type == "删除所有house":
        delallinbond_program(account, password, output_text)
    elif task_type == "header修改":
        headeredit_program(account, password, output_text, mode)
    elif task_type == "更改状态accept":
        statuschange_program(account, password, output_text)
    elif task_type == "BBC数据显示":
        BBC_review_program(account, password, output_text)
    elif task_type == "BBC Document":
        document_program(account, password, output_text)
    elif task_type == "BBC House":
        BBC_House(account, password, output_text)
    elif task_type == "批量放货":
        release_program(account, password, output_text)
    elif task_type == "query":
        query_program(account, password, output_text)
    elif task_type == "bolupdate":
        bolupdate_program(account, password, output_text)
    elif task_type == "reject修复(目前仅AL1,EP7)":
        rejectfix_program(account, password, output_text)
    elif task_type == "itac检测":
        FDA_program(account, password, output_text)
    elif task_type == "steel/al Duty":
        Steel_Aluminum_dutyprogram(account, password, output_text)
    elif task_type == "Line 提取":
        line_extract(account, password, output_text)
    elif task_type == "反向Line 提取":
        reverse_line_extract(account, password, output_text)
    elif task_type == "Nikki template":
        Nikki_template(account, password, output_text)
    elif task_type == "白宫总统办公室联系方式":
        wechat(account, password, output_text)   


# 登录界面
def login_window():
    global windowname
    windowname = 'login'

    login_frame = ctk.CTkFrame(root, fg_color="#1e1e1e", corner_radius=20)
    login_frame.pack(padx=20, pady=20, fill="both", expand=True)

    def proceed_login():
        account = entry_account.get()
        password = entry_password.get()
        if not account or not password:
            messagebox.showerror("错误", "账号或密码不能为空！")
            return
        login_frame.destroy()
        show_main_window(account, password)

    label_account = ctk.CTkLabel(login_frame, text="账号:", font=("Arial", 16), text_color="#FFFFFF")
    label_account.pack(pady=10)
    entry_account = ctk.CTkEntry(login_frame, width=300, height=35, font=("Arial", 12), placeholder_text="请输入账号")
    entry_account.pack(pady=10)

    label_password = ctk.CTkLabel(login_frame, text="密码:", font=("Arial", 16), text_color="#FFFFFF")
    label_password.pack(pady=10)
    entry_password = ctk.CTkEntry(login_frame, width=300, height=35, show="*", font=("Arial", 12),
                                  placeholder_text="请输入密码")
    entry_password.pack(pady=10)

    login_button = ctk.CTkButton(login_frame, text="确认", command=proceed_login, width=200, height=40,
                                 corner_radius=10)
    login_button.pack(pady=20)


# 主界面
def show_main_window(account, password):
    global windowname
    main_frame = ctk.CTkFrame(root, fg_color="#1e1e1e", corner_radius=20)
    main_frame.pack(padx=20, pady=20, fill="both", expand=True)

    def switch_to_task(task_type):
        global windowname
        main_frame.destroy()
        show_task_window(account, password, task_type)
        windowname = 'task'

    def create_button(parent, text, command=None):
        return ctk.CTkButton(
            parent,
            text=text,
            command=command,
            width=150,
            height=150,
            corner_radius=0,
            font=("Arial", 14),
            fg_color="#2e2e2e",
            border_color="#1f6aa5",
            border_width=2,
            hover_color="#3a3a3a",
        )

    scrollable_frame = ctk.CTkScrollableFrame(main_frame, fg_color="transparent", width=540, height=260)
    scrollable_frame.pack(pady=20, padx=10, fill="both", expand=True)

    buttons = [
                  ("QP", lambda: switch_to_task("QP")),
                  ("Transmit", lambda: switch_to_task("Transmit")),
                  ("Hold", lambda: switch_to_task("Hold")),
                  ("DelQP", lambda: switch_to_task("DelQP")),
                  ("删除所有house", lambda: switch_to_task("删除所有house")),
                  ("header修改", lambda: switch_to_task("header修改")),
                  ("更改状态accept", lambda: switch_to_task("更改状态accept")),
                  ("BBC数据显示", lambda: switch_to_task("BBC数据显示")),
                  ("BBC Document", lambda: switch_to_task("BBC Document")),
                  ("BBC House", lambda: switch_to_task("BBC House")),
                  ("梦想成真模拟器", lambda: switch_to_task("梦想成真模拟器")),
                  ("批量放货", lambda: switch_to_task("批量放货")),
                  ("query", lambda: switch_to_task("query")),
                  ("bolupdate", lambda: switch_to_task("bolupdate")),
                  ("reject修复(目前仅AL1,EP7)", lambda: switch_to_task("reject修复(目前仅AL1,EP7)")),
                  ("inbond提取", lambda: switch_to_task("inbond提取")),
                  ("itac检测", lambda: switch_to_task("itac检测")),
                  ("steel/al Duty", lambda: switch_to_task("steel/al Duty")),
                  ("Line 提取", lambda: switch_to_task("Line 提取")),
                  ("反向Line 提取", lambda: switch_to_task("反向Line 提取")),
                  ("Nikki template", lambda: switch_to_task("Nikki template")),
                  ("白宫总统办公室联系方式", lambda: switch_to_task("白宫总统办公室联系方式")),

              ] + [("未解锁功能", None)] * 8  # 增加点按钮以便显示滚动效果

    def create_button(parent, text, command=None):
        return ctk.CTkButton(
            parent,
            text=text,
            command=command,
            width=150,
            height=150,
            corner_radius=0,
            font=("Arial", 14),
            fg_color="#2e2e2e",
            border_color="#1f6aa5",
            border_width=2,
            hover_color="#3a3a3a",
        )

    for i in range(9):  # 行
        for j in range(3):  # 列
            idx = i * 3 + j
            if idx < len(buttons):
                btn_text, btn_cmd = buttons[idx]
                btn = btn = create_button(scrollable_frame, btn_text, btn_cmd)
                btn.grid(row=i, column=j, padx=10, pady=10)


# 任务界面
def show_task_window(account, password, task_type):
    task_frame = ctk.CTkFrame(root, fg_color="#1e1e1e", corner_radius=20)
    task_frame.pack(padx=20, pady=20, fill="both", expand=True)

    output_text = ctk.CTkTextbox(
        task_frame, width=520, height=120, font=("Consolas", 11),
        fg_color="#1e1e1e", text_color="#FFFFFF", corner_radius=10,
        border_width=2, border_color="#007acc"
    )
    output_text.pack(pady=10)

    if task_type == "Hold" or task_type == "header修改":
        mode_var = ctk.StringVar()

        mode_label = ctk.CTkLabel(task_frame, text="请选择操作模式：", text_color="white")
        mode_label.pack()

        if task_type == "Hold":
            mode_var.set("仅查找")
            mode_dropdown = ctk.CTkOptionMenu(
                task_frame,
                variable=mode_var,
                values=["仅查找", "删除"],
                width=120
            )
        elif task_type == "header修改":
            mode_var.set("61")
            mode_dropdown = ctk.CTkOptionMenu(
                task_frame,
                variable=mode_var,
                values=["61", "63"],
                width=120
            )

        mode_dropdown.pack(pady=5)
    if task_type == "梦想成真模拟器":
        output_text.destroy()
        title_frame = ctk.CTkFrame(task_frame, fg_color="transparent")
        title_frame.pack(pady=30)

        dream_label1 = ctk.CTkLabel(title_frame, text="梦", text_color="#FF69B4",
                                    font=("Comic Sans MS", 28, "bold"))
        dream_label1.pack(side="left")
        dream_label2 = ctk.CTkLabel(title_frame, text="想", text_color="#00BFFF",
                                    font=("Comic Sans MS", 28, "bold"))
        dream_label2.pack(side="left")
        rest_label = ctk.CTkLabel(title_frame, text="成真模拟器", text_color="#FFFFFF",
                                  font=("Comic Sans MS", 26, "bold"))
        rest_label.pack(side="left")

        def transform_dreams():
            progress_win = Toplevel(root)
            progress_win.title("梦想成真中")
            progress_win.geometry("400x150")
            progress_win.configure(bg="white")

            label = tk.Label(progress_win, text="梦想成真中...", font=("Arial", 14), bg="white")
            label.pack(pady=10)

            progress_bar = ttk.Progressbar(progress_win, length=300, mode='determinate')
            progress_bar.pack(pady=10)
            progress_bar["value"] = 0

            def update_bar():
                for i in range(101):
                    progress_bar["value"] = i
                    label.config(text=f"梦想成真中... {i}%")
                    time.sleep(0.05)
                    progress_win.update_idletasks()

                label.config(text="🎉 梦想已成真 🎉")

                # ✅ 达到 100% 时立即替换文字
                def replace_text(widget):
                    try:
                        if hasattr(widget, "cget") and callable(widget.cget):
                            if "text" in widget.keys():
                                text = widget.cget("text")
                                if text:
                                    new_text = text.replace("梦想", "真的").replace("梦", "真").replace("想", "的")
                                    widget.configure(text=new_text)
                    except:
                        pass
                    for child in widget.winfo_children():
                        replace_text(child)

                replace_text(task_frame)

                # ✅ 自动 1 秒后关闭进度窗口
                time.sleep(1)
                progress_win.destroy()

            threading.Thread(target=update_bar, daemon=True).start()

        dream_button = ctk.CTkButton(
            task_frame,
            text="点击把梦想变成真的",
            command=transform_dreams,
            width=250,
            height=60,
            corner_radius=15,
            font=("Comic Sans MS", 18, "bold"),
            fg_color="#FF69B4",
            hover_color="#FF1493"
        )
        dream_button.pack(pady=40)

        back_button = ctk.CTkButton(task_frame, text="返回",
                                    command=lambda: go_back_to_main(task_frame, account, password),
                                    width=200, height=40, corner_radius=10)
        back_button.pack(pady=20)

        return  # 不继续执行下面的通用逻辑

    def start_task():
        output_text.insert("end", f"启动 {task_type} 任务...\n")
        if task_type == "Hold" or task_type == "header修改":
            mode = mode_var.get()
            threading.Thread(target=start_program, args=(account, password, output_text, task_type, mode),
                             daemon=True).start()
        else:
            threading.Thread(target=start_program, args=(account, password, output_text, task_type),
                             daemon=True).start()

    start_button = ctk.CTkButton(task_frame, text="开始任务", command=start_task)
    start_button.pack(pady=10)

    back_button = ctk.CTkButton(task_frame, text="返回", command=lambda: go_back_to_main(task_frame, account, password),
                                width=200, height=40, corner_radius=10)
    back_button.pack(pady=20)


# 返回主界面并停止任务
def go_back_to_main(current_frame, account, password):
    global windowname
    print("销毁当前窗口...")  # 调试打印
    current_frame.destroy()
    stop_event.set()  # 设置停止事件，通知子线程退出
    show_main_window(account, password)
    windowname = 'main'


# 初始化主窗口
root = ctk.CTk()
root.title("冷知识，生鱼片是死鱼片。")
root.geometry("600x420")
root.configure(fg_color="#1e1e1e")

# 显示登录窗口
login_window()

# 启动 GUI 主循环
root.mainloop()
